<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ROBOT LYRIC by Lyric and Aria - Flying Robot Game</title>
    <!-- Redirect to portal if accessed directly on desktop -->
    <script>
        // Only redirect on desktop, not mobile, and not if already in iframe
        if (window.innerWidth > 768 && window.self === window.top) {
            // Redirect to portal to see all games
            window.location.href = 'portal.html';
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #8FBC8F 100%);
            border: 3px solid #2F4F4F;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #gameCanvas {
            display: block;
            background: transparent;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Mobile Touch Controls */
        #mobileControls {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            display: none;
            gap: 5px;
            z-index: 20;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: none; /* Will be shown/hidden by JavaScript based on gameState */
                flex-direction: column;
                align-items: center;
            }
            
            #gameContainer {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                border: none;
                border-radius: 0;
            }
            
            #gameCanvas {
                width: 100% !important;
                height: 100% !important;
            }
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #gameContainer {
                width: 100vw;
                height: 100vh;
                transform: scale(1);
            }
            
            #gameCanvas {
                width: 100vw !important;
                height: 100vh !important;
            }
            
            #mobileControls {
                bottom: 5px;
                gap: 5px;
            }
            
            .mobile-btn {
                padding: 8px 12px;
                font-size: 14px;
                min-width: 45px;
                min-height: 45px;
            }
        }

        .mobile-control-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }

        .mobile-btn {
            background: rgba(52, 73, 94, 0.9);
            color: white;
            border: 3px solid #3498DB;
            border-radius: 15px;
            padding: 15px 25px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            min-width: 60px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }

        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(52, 73, 94, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .mobile-btn.jump {
            background: rgba(46, 204, 113, 0.9);
            border-color: #2ECC71;
        }

        .mobile-btn.boost {
            background: rgba(231, 76, 60, 0.9);
            border-color: #E74C3C;
        }

        .mobile-btn.direction {
            background: rgba(52, 152, 219, 0.9);
            border-color: #3498DB;
        }

        #score {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 8px 16px;
            border-radius: 8px;
            border: 2px solid #F1C40F;
        }
        
        @media (max-width: 768px) {
            #score {
                bottom: 200px;
                font-size: 20px;
                padding: 6px 12px;
            }
        }
        
        #achievementBadges {
            position: absolute;
            top: 60px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 15;
            max-width: 200px;
        }
        
        .achievement-badge {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: none;
            border: 2px solid #FF8C00;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            animation: badgeGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes badgeGlow {
            from { box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
            to { box-shadow: 0 2px 8px rgba(255,215,0,0.6); }
        }

        #level {
            position: absolute;
            top: 20px;
            left: 30px;
            color: #2F4F4F;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }

        #playerName {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #2F4F4F;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
            z-index: 15;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #expandIframeBtn {
            position: absolute;
            top: 20px;
            right: 80px;
            background: rgba(46, 204, 113, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
            z-index: 20;
            pointer-events: auto;
            display: none;
        }

        #expandIframeBtn:hover {
            background: rgba(39, 174, 96, 0.9);
        }

        #settingsBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(52, 73, 94, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
            z-index: 20;
            pointer-events: auto;
        }

        #settingsBtn:hover {
            background: rgba(52, 73, 94, 1);
        }

        #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            pointer-events: all;
            min-width: 400px;
            max-width: 500px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }

        #settingsMenu h2 {
            margin-bottom: 20px;
            color: #3498DB;
        }

        .setting-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .setting-group input, .setting-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: white;
            font-size: 14px;
        }

        .background-preview {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .bg-option {
            width: 60px;
            height: 40px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .bg-option.selected {
            border-color: #3498DB;
        }

        .bg-option:hover {
            border-color: #5DADE2;
        }

        #leaderboard {
            z-index: 1001 !important;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            pointer-events: all;
            min-width: 400px;
            max-width: 500px;
        }

        #leaderboard h2 {
            margin-bottom: 20px;
            color: #F39C12;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .leaderboard-entry.current-player {
            background: rgba(52, 152, 219, 0.3);
            border: 2px solid #3498DB;
        }

        .rank {
            font-weight: bold;
            color: #F39C12;
            min-width: 30px;
        }

        .player-name {
            flex: 1;
            text-align: left;
            margin-left: 15px;
        }

        .score {
            font-weight: bold;
            color: #2ECC71;
        }

        .level {
            color: #E74C3C;
            margin-left: 10px;
        }

        #powerUpStatus {
            position: absolute;
            top: 60px;
            right: 20px;
            color: #2F4F4F;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
            z-index: 15;
        }

        .power-up-indicator {
            display: inline-block;
            margin-top: 3px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            white-space: nowrap;
        }

        .shield-indicator {
            background: rgba(52, 152, 219, 0.8);
            color: white;
        }

        .rocket-indicator {
            background: rgba(231, 76, 60, 0.8);
            color: white;
        }

        #powerBar {
            position: absolute;
            top: 140px;
            right: 20px;
            width: 180px;
            height: 18px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #2F4F4F;
            border-radius: 10px;
            overflow: hidden;
            z-index: 15;
        }

        #powerBarFill {
            height: 100%;
            background: linear-gradient(to right, #E74C3C, #F39C12, #2ECC71);
            width: 100%;
            transition: width 0.3s ease;
        }

        #player2Status {
            position: absolute;
            top: 165px;
            right: 20px;
            color: #2F4F4F;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
            z-index: 15;
        }

        #superCoinTime {
            position: absolute;
            top: 165px;
            right: 20px;
            color: #F39C12;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
            z-index: 15;
        }
        
        #spendingCurrency {
            position: absolute;
            top: 195px;
            right: 20px;
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 16;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #FFD700;
        }
        
        #achievementBank {
            position: absolute;
            top: 225px;
            right: 20px;
            width: 180px;
            max-height: 120px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 8px;
            z-index: 15;
            overflow-y: auto;
        }
        
        #achievementBankTitle {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        #achievementBankList {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .achievement-bank-item {
            background: rgba(255,215,0,0.2);
            color: #FFD700;
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255,215,0,0.5);
            animation: achievementSlideIn 0.3s ease-out;
        }
        
        @keyframes achievementSlideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            pointer-events: all;
        }

        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #FF6B6B;
        }

        #finalScore {
            font-size: 24px;
            margin-bottom: 20px;
        }

        #restartBtn {
            background: #4ECDC4;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #restartBtn:hover {
            background: #45B7B8;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #2F4F4F;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }

        #nameInputScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: block;
            pointer-events: all;
            min-width: 400px;
            max-width: 500px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }

        #nameInputScreen h1 {
            margin-bottom: 20px;
            color: #3498DB;
            font-size: 36px;
            font-weight: bold;
        }

        #nameInputScreen h2 {
            margin-bottom: 30px;
            color: #F39C12;
            font-size: 24px;
        }

        #nameInputScreen input {
            width: 100%;
            padding: 15px;
            border: 2px solid #3498DB;
            border-radius: 8px;
            background: #333;
            color: white;
            font-size: 18px;
            text-align: center;
            margin-bottom: 20px;
        }

        #nameInputScreen input:focus {
            outline: none;
            border-color: #5DADE2;
        }

        #startGameBtn {
            background: #27AE60;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            margin-right: 10px;
        }

        #startGameBtn:hover {
            background: #2ECC71;
        }

        #startGameBtn:disabled {
            background: #7F8C8D;
            cursor: not-allowed;
        }

        .cloud {
            position: absolute;
            background: white;
            border-radius: 50px;
            opacity: 0.8;
        }

        .cloud:before {
            content: '';
            position: absolute;
            background: white;
            border-radius: 50px;
        }

        .cloud:after {
            content: '';
            position: absolute;
            background: white;
            border-radius: 50px;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div id="level">Level 1</div>
            <div id="playerName">Player</div>
            <div id="achievementBadges"></div>
            <div id="powerUpStatus">
                <span id="shieldCount">üõ°Ô∏è 0</span>
                <span id="invincibleTime" class="power-up-indicator shield-indicator" style="display: none;">‚ú® 0s</span>
                <span id="rocketTime" class="power-up-indicator rocket-indicator" style="display: none;">üöÄ 0s</span>
                <span id="rocketBoostStored" class="power-up-indicator" style="display: none;">‚ö° Boost: 0s</span>
                <span id="rocketBoostActive" class="power-up-indicator" style="display: none;">‚ö°‚ö° BOOST!</span>
            </div>
            <div id="powerBar">
                <div id="powerBarFill"></div>
            </div>
            <div id="player2Status">Player 2: üöÄ 0</div>
            <div id="superCoinTime" style="display: none;">‚≠ê 0s</div>
            <div id="spendingCurrency">üí∞ 0</div>
            <div id="achievementBank">
                <div id="achievementBankTitle">üèÜ Achievements</div>
                <div id="achievementBankList"></div>
            </div>
            <button id="expandIframeBtn">‚õ∂ Expand</button>
            <button id="settingsBtn">‚öôÔ∏è Settings</button>
            <button id="soundToggle" style="position: absolute; top: 60px; right: 20px; padding: 8px 12px; background: #3498DB; color: white; border: none; border-radius: 5px; cursor: pointer; z-index: 20; pointer-events: auto; font-size: 14px;">üîä Sound</button>
            <div id="instructions">Click or Press SPACE to Fly!<br><br>ü™ô Coins = 3s Invincibility (1 per coin)<br>‚≠ê Super Coins = 8 Bonus Coins!<br>üöÄ Rockets = Slow Motion + Full Control<br>‚ö° Rocket Boosts = Speed Boost (Press B to activate)<br><br>Player 1: SPACE to jump, WASD for rockets, B for boost<br>Player 2: Press P to activate (unlocks after first coin)<br>Player 2: Arrow Keys + ENTER to fire<br>Press R to Restart</div>
            <div id="score">Score: 0</div>
            
            <!-- Mobile Touch Controls -->
            <div id="mobileControls">
                <div class="mobile-control-row">
                    <button class="mobile-btn direction" id="mobileLeft">‚Üê</button>
                    <button class="mobile-btn jump" id="mobileJump">‚Üë</button>
                    <button class="mobile-btn direction" id="mobileRight">‚Üí</button>
                </div>
                <div class="mobile-control-row">
                    <button class="mobile-btn boost" id="mobileBoost">‚ö° BOOST</button>
                </div>
            </div>
            
            <div id="nameInputScreen">
                <h1>ü§ñ ROBOT LYRIC</h1>
                <h2 style="font-size: 16px; color: #666; margin-top: -10px; margin-bottom: 20px;">by Lyric and Aria</h2>
                <h2>Enter Your Name</h2>
                <input type="text" id="playerNameInputMain" placeholder="Enter your name" maxlength="15" autofocus>
                <br>
                <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 20px; width: 100%;">
                    <button id="startGameBtn" disabled style="width: 200px; padding: 15px 30px; font-size: 18px; border-radius: 8px; cursor: pointer; background: #27AE60; color: white; border: none;">Start Game</button>
                    <button id="settingsBtnMain" style="width: 200px; padding: 15px 30px; font-size: 18px; border-radius: 8px; cursor: pointer; background: #F39C12; color: white; border: none;">‚öôÔ∏è Settings</button>
                </div>
                <div style="margin-top: 15px; font-size: 14px; color: #666; text-align: center;">
                    üí° Your name will be saved globally and shown on the leaderboard
                </div>
            </div>
            
            <div id="settingsMenu">
                <h2>‚öôÔ∏è Game Settings</h2>
                <div class="setting-group">
                    <label>Background Theme:</label>
                    <div class="background-preview">
                        <div class="bg-option selected" data-bg="day" style="background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #8FBC8F 100%);"></div>
                        <div class="bg-option" data-bg="sunset" style="background: linear-gradient(to bottom, #FF6B6B 0%, #FF8E53 30%, #FF6B9D 70%, #C44569 100%);"></div>
                        <div class="bg-option" data-bg="aurora" style="background: linear-gradient(to bottom, #2C3E50 0%, #3498DB 30%, #9B59B6 60%, #E74C3C 100%);"></div>
                        <div class="bg-option" data-bg="night" style="background: linear-gradient(to bottom, #1A1A2E 0%, #16213E 50%, #0F3460 100%);"></div>
                    </div>
                </div>
                <div class="setting-group" style="margin-top: 20px;">
                    <label>üîä Music Volume: <span id="musicVolumeValue">30</span>%</label>
                    <input type="range" id="musicVolumeSlider" min="0" max="100" value="30" style="width: 100%; margin-top: 5px;">
                </div>
                <div class="setting-group" style="margin-top: 15px;">
                    <label>üîî Sound Effects Volume: <span id="soundVolumeValue">40</span>%</label>
                    <input type="range" id="soundVolumeSlider" min="0" max="100" value="40" style="width: 100%; margin-top: 5px;">
                </div>
                <div class="setting-group" style="margin-top: 15px;">
                    <label>
                        <input type="checkbox" id="soundEnabledCheckbox" checked> Enable Sound
                    </label>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap;">
                    <button id="saveSettings" style="flex: 1; min-width: 120px; padding: 10px; background: #27AE60; color: white; border: none; border-radius: 8px; cursor: pointer;">Save</button>
                    <button id="showLeaderboard" style="flex: 1; min-width: 120px; padding: 10px; background: #F39C12; color: white; border: none; border-radius: 8px; cursor: pointer;">Leaderboard</button>
                    <button id="showMultiplayer" style="flex: 1; min-width: 120px; padding: 10px; background: #9B59B6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">üåê Multiplayer</button>
                    <button id="closeSettings" style="flex: 1; min-width: 120px; padding: 10px; background: #E74C3C; color: white; border: none; border-radius: 8px; cursor: pointer;">Close</button>
                </div>
            </div>

            <div id="leaderboard">
                <h2>üèÜ Leaderboard</h2>
                <div id="leaderboardList"></div>
                <button id="closeLeaderboard" style="margin-top: 20px; padding: 10px 20px; background: #E74C3C; color: white; border: none; border-radius: 8px; cursor: pointer;">Close</button>
            </div>

            <div id="gameOver">
                <h2>Game Over!</h2>
                <div id="finalScore">Score: 0 | Level: 0</div>
                <button id="restartBtn">Play Again</button>
                <button id="multiplayerFromGameOver" style="margin-top: 10px; width: 100%; padding: 10px; background: #9B59B6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">üåê Multiplayer</button>
            </div>

            <!-- Level Editor -->
            <div id="levelEditor" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; display: none; z-index: 1000; pointer-events: all; min-width: 400px;">
                <h2>üìù Level Editor</h2>
                <div style="margin: 20px 0;">
                    <label>Mode:</label>
                    <select id="editorModeSelect" style="width: 100%; padding: 8px; margin-top: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                        <option value="obstacle">Obstacle</option>
                        <option value="coin">Coin</option>
                        <option value="powerup">Power-up</option>
                    </select>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button id="saveLevelBtn" style="flex: 1; padding: 10px; background: #27AE60; color: white; border: none; border-radius: 8px; cursor: pointer;">Save Level</button>
                    <button id="loadLevelBtn" style="flex: 1; padding: 10px; background: #3498DB; color: white; border: none; border-radius: 8px; cursor: pointer;">Load Level</button>
                    <button id="closeEditorBtn" style="flex: 1; padding: 10px; background: #E74C3C; color: white; border: none; border-radius: 8px; cursor: pointer;">Close</button>
                </div>
                <div style="margin-top: 15px; font-size: 12px; color: #999;">
                    Click on canvas to place items. Press E to toggle editor.
                </div>
            </div>

            <!-- Multiplayer Menu -->
            <div id="multiplayerMenu" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; display: none; z-index: 1000; pointer-events: all; min-width: 400px;">
                <h2>üåê Multiplayer</h2>
                <div style="margin: 20px 0;">
                    <button id="createRoomBtn" style="width: 100%; padding: 15px; background: #27AE60; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 10px;">Create Room</button>
                    <input type="text" id="roomIdInput" placeholder="Enter Room ID" style="width: 100%; padding: 10px; margin-bottom: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                    <button id="joinRoomBtn" style="width: 100%; padding: 15px; background: #3498DB; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 10px;">Join Room</button>
                    <div id="roomStatus" style="margin-top: 15px; font-size: 14px; color: #999;"></div>
                </div>
                <button id="closeMultiplayerBtn" style="width: 100%; padding: 10px; background: #E74C3C; color: white; border: none; border-radius: 8px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>

    <script>
        class InTheAirGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.scoreElement = document.getElementById('score');
                this.levelElement = document.getElementById('level');
                this.playerNameElement = document.getElementById('playerName');
                this.gameOverElement = document.getElementById('gameOver');
                this.instructionsElement = document.getElementById('instructions');
                this.finalScoreElement = document.getElementById('finalScore');
                this.restartBtn = document.getElementById('restartBtn');
                this.multiplayerFromGameOverBtn = document.getElementById('multiplayerFromGameOver');
                this.mobileControls = document.getElementById('mobileControls');
                
                // Iframe expansion elements
                this.expandIframeBtn = document.getElementById('expandIframeBtn');
                this.isInIframe = window.self !== window.top;
                
                // Settings elements
                this.settingsBtn = document.getElementById('settingsBtn');
                this.settingsMenu = document.getElementById('settingsMenu');
                this.saveSettingsBtn = document.getElementById('saveSettings');
                this.closeSettingsBtn = document.getElementById('closeSettings');
                this.showLeaderboardBtn = document.getElementById('showLeaderboard');
                
                // Leaderboard elements
                this.leaderboard = document.getElementById('leaderboard');
                this.leaderboardList = document.getElementById('leaderboardList');
                this.closeLeaderboardBtn = document.getElementById('closeLeaderboard');
                
                // Name input screen elements
                this.nameInputScreen = document.getElementById('nameInputScreen');
                this.playerNameInputMain = document.getElementById('playerNameInputMain');
                this.startGameBtn = document.getElementById('startGameBtn');
                this.settingsBtnMain = document.getElementById('settingsBtnMain');
                
                // Power-up elements
                this.shieldCountElement = document.getElementById('shieldCount');
                this.invincibleTimeElement = document.getElementById('invincibleTime');
                this.rocketTimeElement = document.getElementById('rocketTime');
                this.rocketBoostStoredElement = document.getElementById('rocketBoostStored');
                this.rocketBoostActiveElement = document.getElementById('rocketBoostActive');
                this.powerBarFill = document.getElementById('powerBarFill');
                this.player2StatusElement = document.getElementById('player2Status');
                this.superCoinTimeElement = document.getElementById('superCoinTime');
                this.soundToggleBtn = document.getElementById('soundToggle');
                this.achievementBadgesElement = document.getElementById('achievementBadges');
                this.spendingCurrencyElement = document.getElementById('spendingCurrency');
                this.achievementBankList = document.getElementById('achievementBankList');
                
                // Level editor elements
                this.levelEditorElement = document.getElementById('levelEditor');
                this.editorModeSelect = document.getElementById('editorModeSelect');
                this.saveLevelBtn = document.getElementById('saveLevelBtn');
                this.loadLevelBtn = document.getElementById('loadLevelBtn');
                this.closeEditorBtn = document.getElementById('closeEditorBtn');
                
                // Multiplayer elements
                this.multiplayerMenuElement = document.getElementById('multiplayerMenu');
                this.createRoomBtn = document.getElementById('createRoomBtn');
                this.joinRoomBtn = document.getElementById('joinRoomBtn');
                this.roomIdInput = document.getElementById('roomIdInput');
                this.roomStatusElement = document.getElementById('roomStatus');
                this.closeMultiplayerBtn = document.getElementById('closeMultiplayerBtn');

                this.gameWidth = 800;
                this.gameHeight = 600;
                this.gravity = 0.4; // Slightly reduced for robot
                this.jumpForce = -10; // Slightly reduced for robot
                this.baseObstacleSpeed = 2; // Slower starting speed
                this.rocketSpeedMultiplier = 0.3; // Speed reduction during rocket mode
                // Responsive obstacle gap - larger on mobile for easier navigation
                const isMobile = window.innerWidth <= 768 || window.screen.width <= 768;
                this.obstacleGap = isMobile ? 250 : 200; // Larger gap on mobile
                this.obstacleWidth = 60;

                this.gameState = 'nameInput'; // nameInput, waiting, playing, gameOver
                this.score = 0;
                this.level = 1;
                this.obstacleSpeed = this.baseObstacleSpeed;
                this.robot = {
                    x: 100,
                    y: this.gameHeight / 2,
                    width: 45,
                    height: 35,
                    velocity: 0,
                    rotation: 0,
                    eyeGlow: 0 // For robot eye animation
                };
                this.obstacles = [];
                this.clouds = [];
                this.lastObstacleTime = 0;
                this.obstacleInterval = 2500; // Slower initial obstacle generation
                this.pointsToNextLevel = 5; // Points needed to advance to next level
                
                // Power-up systems
                this.coins = [];
                this.superCoins = [];
                this.rockets = [];
                this.rocketBoosts = []; // New rocket boost collectibles
                this.magnets = []; // Magnet power-up (attracts coins)
                this.freezes = []; // Freeze power-up (freezes obstacles)
                this.doublePoints = []; // Double points power-up
                this.magnetActive = false;
                this.magnetTimeLeft = 0;
                this.freezeActive = false;
                this.freezeTimeLeft = 0;
                this.doublePointsActive = false;
                this.doublePointsTimeLeft = 0;
                this.lastMagnetTime = 0;
                this.lastFreezeTime = 0;
                this.lastDoublePointsTime = 0;
                this.magnetInterval = 20000; // 20 seconds
                this.freezeInterval = 25000; // 25 seconds
                this.doublePointsInterval = 30000; // 30 seconds
                this.shieldCount = 0;
                this.rocketActive = false;
                this.rocketTimeLeft = 0;
                // Rocket boost system (separate from slow-motion rockets)
                this.rocketBoostStored = 0; // Stored boost time in milliseconds (max 3000)
                this.rocketBoostActive = false; // Currently using boost
                this.rocketBoostTimeLeft = 0; // Remaining active boost time
                this.rocketBoostSpeedMultiplier = 1.5; // Speed increase when boost is active
                this.invincible = false;
                this.invincibleTimeLeft = 0;
                this.lastCoinTime = 0;
                this.lastSuperCoinTime = 0;
                this.lastRocketTime = 0;
                this.lastRocketBoostTime = 0;
                this.coinInterval = 6000; // 6 seconds between coins (reduced frequency)
                this.rocketBoostInterval = 10000; // 10 seconds between rocket boosts
                
                // Coin rarity system
                this.coinRarities = [
                    { name: 'Bronze', color: '#CD7F32', value: 1, rarity: 0.35, lifetime: 20 },     // 35% - 20 gates
                    { name: 'Silver', color: '#C0C0C0', value: 2, rarity: 0.25, lifetime: 20 },     // 25% - 20 gates
                    { name: 'Gold', color: '#FFD700', value: 3, rarity: 0.20, lifetime: 20 },       // 20% - 20 gates
                    { name: 'Emerald', color: '#50C878', value: 5, rarity: 0.10, lifetime: 10 },    // 10% - 10 gates
                    { name: 'Sapphire', color: '#0F52BA', value: 8, rarity: 0.06, lifetime: 10 },   // 6% - 10 gates
                    { name: 'Ruby', color: '#E0115F', value: 12, rarity: 0.03, lifetime: 10 },      // 3% - 10 gates
                    { name: 'Diamond', color: '#B9F2FF', value: 20, rarity: 0.01, lifetime: 10 }    // 1% - 10 gates
                ];
                this.robotUpgradeLevel = 0;
                this.spendingCurrency = 0;
                
                // Achievement system
                this.achievements = {
                    firstCoin: false,
                    firstRocket: false,
                    firstOilCan: false,
                    firstSuperCoin: false,
                    firstMagnet: false,
                    firstFreeze: false,
                    firstDoublePoints: false,
                    firstRocketBoost: false,
                    level5: false,
                    level10: false,
                    level20: false,
                    level30: false,
                    level50: false,
                    score100: false,
                    score500: false,
                    score1000: false,
                    score2000: false,
                    score5000: false,
                    perfectRun: false,
                    missileMaster: false,
                    coinCollector: false, // Collect 50 coins
                    powerUpMaster: false, // Collect 20 power-ups
                    speedDemon: false, // Use 10 rocket boosts
                    invincibleWarrior: false, // Use 20 shields
                    bossSlayer: false, // Defeat first boss
                    bossMaster: false, // Defeat 5 bosses
                    survivalist: false, // Survive 5 minutes
                    marathonRunner: false // Survive 10 minutes
                };
                this.achievementStats = {
                    coinsCollected: 0,
                    powerUpsCollected: 0,
                    rocketBoostsUsed: 0,
                    shieldsUsed: 0,
                    bossesDefeated: 0,
                    playTime: 0
                };
                this.achievementBadgesElement = null;
                this.superCoinInterval = 30000; // 30 seconds between super coins (rare)
                this.rocketInterval = 8000; // 8 seconds between rockets
                this.superCoinActive = false;
                this.superCoinTimeLeft = 0;
                
                // Player 2 system
                this.player2Active = false;
                this.player2Missiles = 0;
                this.missiles = [];
                this.robotPower = 100; // Power percentage
                this.player1FirstCoinCollected = false; // Player 2 disabled until first coin
                this.lastMissileTime = 0;
                this.missileCooldown = 500; // 0.5 seconds between missiles
                
                // Oil can system
                this.oilCans = [];
                this.oilCanInterval = 15000; // 15 seconds between oil cans
                this.lastOilCanTime = 0;
                
                // Audio system
                this.audioContext = null;
                this.musicPlaying = false;
                this.musicIntensity = 1;
                this.musicTempo = 140; // BPM - more energetic
                this.musicTime = 0;
                this.musicPattern = 0;
                this.soundEnabled = true;
                this.audioContextReady = false;
                this.musicVolume = 0.3;
                this.soundEffectVolume = 0.4;
                this.lastAutoSaveTime = 0;
                this.autoSaveInterval = 30000; // 30 seconds

                // Boss battle system
                this.bosses = [];
                this.bossActive = false;
                this.currentBoss = null;
                this.bossSpawnInterval = 60000; // Spawn boss every 60 seconds
                this.lastBossSpawnTime = 0;
                this.bossHealth = 0;
                this.bossMaxHealth = 100;
                this.bossPhase = 0;
                this.bossAttackPattern = 0;
                this.bossAttackCooldown = 0;
                this.lastProjectileHitTime = 0;
                this.projectileHitCooldown = 300; // 300ms cooldown between projectile hits (prevents rapid-fire)
                this.lastBossHitTime = 0;
                this.bossHitCooldown = 500; // 500ms cooldown between boss hits
                this.hitProjectiles = new Set(); // Track which projectiles have already hit
                this.obstaclesPassed = 0; // Track gates/obstacles passed
                this.bossModeEnabled = false; // Boss mode completely disabled
                this.bossModePromptShown = false; // Track if prompt has been shown

                // Level editor system
                this.levelEditorActive = false;
                this.editorObstacles = [];
                this.editorMode = 'obstacle'; // 'obstacle', 'coin', 'powerup'
                this.savedLevels = [];

                // Multiplayer system
                this.multiplayerActive = false;
                this.peerConnection = null;
                this.dataChannel = null;
                this.remotePlayer = null;
                this.isHost = false;
                this.roomId = null;

                // Player and settings data
                this.playerName = 'Player';
                this.currentBackground = 'day';
                this.backgrounds = {
                    day: {
                        gradient: ['#87CEEB', '#98FB98', '#8FBC8F'],
                        cloudColor: 'rgba(255, 255, 255, 0.8)',
                        textColor: '#2F4F4F'
                    },
                    sunset: {
                        gradient: ['#FF6B6B', '#FF8E53', '#FF6B9D', '#C44569'],
                        cloudColor: 'rgba(255, 255, 255, 0.6)',
                        textColor: '#FFFFFF'
                    },
                    aurora: {
                        gradient: ['#2C3E50', '#3498DB', '#9B59B6', '#E74C3C'],
                        cloudColor: 'rgba(255, 255, 255, 0.4)',
                        textColor: '#FFFFFF'
                    },
                    night: {
                        gradient: ['#1A1A2E', '#16213E', '#0F3460'],
                        cloudColor: 'rgba(255, 255, 255, 0.3)',
                        textColor: '#FFFFFF'
                    }
                };

                this.init();
                this.initAudio();
            }

            init() {
                // Setup iframe communication
                this.setupIframeCommunication();
                
                // Show/hide expand button based on iframe status
                if (this.isInIframe && this.expandIframeBtn) {
                    this.expandIframeBtn.style.display = 'block';
                } else if (this.expandIframeBtn) {
                    this.expandIframeBtn.style.display = 'none';
                }
                
                this.loadSettings();
                this.setupEventListeners();
                this.createClouds();
                this.updateUI();
                // Add window resize and orientation change handlers
                window.addEventListener('resize', () => {
                    setTimeout(() => {
                        this.handleResize();
                        this.updateMobileControlsVisibility();
                    }, 100);
                });
                
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.handleResize();
                        this.updateMobileControlsVisibility();
                    }, 200);
                });
                
                // Initial resize
                setTimeout(() => {
                    this.handleResize();
                    this.updateMobileControlsVisibility();
                }, 100);
                
                if (this.gameState === 'nameInput') {
                    this.showNameInputScreen();
                } else {
                    this.instructionsElement.style.display = 'block';
                }
                
                this.gameLoop();
            }
            
            handleResize() {
                // Adjust canvas size for mobile and landscape
                const container = document.getElementById('gameContainer');
                const canvas = this.canvas;
                
                if (!canvas || !container) return;
                
                // Use window dimensions or screen dimensions for mobile
                const isMobile = window.innerWidth <= 768 || window.screen.width <= 768;
                
                // Update obstacle gap for mobile responsiveness
                this.obstacleGap = isMobile ? 250 : 200;
                
                if (isMobile) {
                    // Mobile mode - use full viewport
                    const width = window.innerWidth || window.screen.width;
                    const height = window.innerHeight || window.screen.height;
                    
                    container.style.width = width + 'px';
                    container.style.height = height + 'px';
                    container.style.maxWidth = '100vw';
                    container.style.maxHeight = '100vh';
                    
                    // Set canvas actual size (not just CSS)
                    canvas.width = width;
                    canvas.height = height;
                    this.gameWidth = width;
                    this.gameHeight = height;
                    
                    // Update robot position if needed
                    if (this.robot) {
                        this.robot.y = Math.min(this.robot.y, height - 50);
                    }
                } else {
                    // Desktop mode - use fixed size
                    container.style.width = '800px';
                    container.style.height = '600px';
                    container.style.maxWidth = '800px';
                    container.style.maxHeight = '600px';
                    
                    canvas.width = 800;
                    canvas.height = 600;
                    this.gameWidth = 800;
                    this.gameHeight = 600;
                }
            }

            setupEventListeners() {
                // Mouse click
                this.canvas.addEventListener('click', (e) => {
                    try {
                        // Resume audio context on first user interaction
                        if (!this.audioContextReady && this.audioContext) {
                            this.resumeAudioContext();
                        }
                        
                        // Only handle clicks if not in level editor mode
                        if (this.levelEditorActive) {
                            // Level editor handles clicks separately
                            return;
                        }
                        
                        // Defer to prevent blocking
                        setTimeout(() => {
                            try {
                                if (this.gameState === 'waiting') {
                                    this.startGame();
                                } else if (this.gameState === 'playing') {
                                    this.jump();
                                }
                            } catch (error) {
                                console.error('Error in canvas click handler:', error);
                            }
                        }, 0);
                    } catch (error) {
                        console.error('Error in canvas click:', error);
                    }
                });

                // Mobile touch controls
                let touchStartY = 0;
                let touchStartX = 0;
                let isTouching = false;
                
                this.canvas.addEventListener('touchstart', (e) => {
                    try {
                        e.preventDefault();
                        // Resume audio context on first user interaction
                        if (!this.audioContextReady && this.audioContext) {
                            this.resumeAudioContext();
                        }
                        
                        const touch = e.touches && e.touches[0];
                        if (!touch) return;
                        
                        touchStartY = touch.clientY;
                        touchStartX = touch.clientX;
                        isTouching = true;
                        
                        // Defer game actions to prevent blocking
                        setTimeout(() => {
                            try {
                                if (this.gameState === 'waiting') {
                                    this.startGame();
                                } else if (this.gameState === 'playing') {
                                    this.jump();
                                }
                            } catch (error) {
                                console.error('Error in touchstart game action:', error);
                            }
                        }, 0);
                    } catch (error) {
                        console.error('Error in touchstart handler:', error);
                    }
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    try {
                        e.preventDefault();
                        if (!isTouching || this.gameState !== 'playing') return;
                        
                        const touch = e.touches && e.touches[0];
                        if (!touch || !this.robot) return;
                        
                        const deltaY = touch.clientY - touchStartY;
                        const deltaX = touch.clientX - touchStartX;
                        
                        // Vertical movement (jump/fall)
                        if (Math.abs(deltaY) > 10) {
                            if (deltaY < 0) {
                                // Swipe up - jump
                                this.robot.velocity = -this.jumpForce;
                            } else {
                                // Swipe down - fall faster
                                this.robot.velocity = Math.min((this.robot.velocity || 0) + 2, 10);
                            }
                            touchStartY = touch.clientY;
                        }
                        
                        // Horizontal movement
                        if (Math.abs(deltaX) > 10) {
                            const newX = (this.robot.x || 0) + (deltaX * 0.5);
                            this.robot.x = Math.max(50, Math.min(this.gameWidth - 50, newX));
                            touchStartX = touch.clientX;
                        }
                    } catch (error) {
                        console.error('Error in touchmove handler:', error);
                    }
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', (e) => {
                    try {
                        e.preventDefault();
                        isTouching = false;
                    } catch (error) {
                        console.error('Error in touchend handler:', error);
                    }
                }, { passive: false });
                
                // Prevent scrolling on mobile (removed duplicate - already handled above)

                // Keyboard controls
                // Keyup handler for rocket boost (stop when B is released)
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'KeyB' && this.gameState === 'playing') {
                        if (this.rocketBoostActive) {
                            this.stopRocketBoost();
                        }
                    }
                });

                document.addEventListener('keydown', (e) => {
                    // Resume audio context on first user interaction
                    if (!this.audioContextReady && this.audioContext) {
                        this.resumeAudioContext();
                    }
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (this.gameState === 'waiting') {
                            this.startGame();
                        } else if (this.gameState === 'playing') {
                            this.jump();
                        }
                    } else if (e.code === 'KeyR' && this.gameState === 'gameOver') {
                        this.restart();
                    } else if (e.code === 'Escape') {
                        this.closeAllMenus();
                    } else if (e.code === 'KeyP' && this.gameState === 'playing') {
                        // Toggle Player 2 (only if Player 1 has collected first coin)
                        if (!this.player1FirstCoinCollected) {
                            console.log("Player 2 is locked! Collect your first coin to unlock Player 2.");
                            return;
                        }
                        this.player2Active = !this.player2Active;
                        if (this.player2Active) {
                            this.player2Missiles = 3; // Give Player 2 some initial missiles
                            console.log("Player 2 activated!");
                        } else {
                            console.log("Player 2 deactivated!");
                        }
                    } else if (e.code === 'KeyB' && this.gameState === 'playing') {
                        // Activate rocket boost (press and hold)
                        if (this.rocketBoostStored > 0 && !this.rocketBoostActive) {
                            this.activateRocketBoost();
                        } else if (this.rocketBoostActive) {
                            // If already active, continue using boost (handled in update)
                        }
                    } else if (this.gameState === 'playing' && this.rocketActive) {
                        // Improved rocket controls
                        if (e.code === 'KeyW' || e.code === 'ArrowUp') {
                            e.preventDefault();
                            this.robot.velocity = -this.jumpForce * 1.2; // More responsive
                        } else if (e.code === 'KeyS' || e.code === 'ArrowDown') {
                            e.preventDefault();
                            this.robot.velocity = this.jumpForce * 0.8; // More responsive
                        } else if (e.code === 'KeyA' || e.code === 'ArrowLeft') {
                            e.preventDefault();
                            this.robot.x = Math.max(50, this.robot.x - 8); // Faster horizontal movement
                        } else if (e.code === 'KeyD' || e.code === 'ArrowRight') {
                            e.preventDefault();
                            this.robot.x = Math.min(this.gameWidth - 50, this.robot.x + 8); // Faster horizontal movement
                        }
                    } else if (this.gameState === 'playing' && this.player2Active) {
                        // Player 2 controls
                        if (e.code === 'ArrowUp') {
                            e.preventDefault();
                            this.robot.velocity = -this.jumpForce * 0.6;
                        } else if (e.code === 'ArrowDown') {
                            e.preventDefault();
                            this.robot.velocity = this.jumpForce * 0.4;
                        } else if (e.code === 'ArrowLeft') {
                            e.preventDefault();
                            this.robot.x = Math.max(50, this.robot.x - 6);
                        } else if (e.code === 'ArrowRight') {
                            e.preventDefault();
                            this.robot.x = Math.min(this.gameWidth - 50, this.robot.x + 6);
                        } else if (e.code === 'Enter') {
                            e.preventDefault();
                            this.fireMissile();
                        }
                    }
                });

                // Restart button
                this.restartBtn.addEventListener('click', () => {
                    this.restart();
                });

                // Multiplayer button from game over screen
                if (this.multiplayerFromGameOverBtn) {
                    this.multiplayerFromGameOverBtn.addEventListener('click', () => {
                        console.log('Multiplayer button clicked from game over');
                        this.showMultiplayerMenu();
                    });
                }

                // Settings button
                this.settingsBtn.addEventListener('click', () => {
                    this.showSettings();
                });

                // Sound toggle button
                this.soundToggleBtn.addEventListener('click', () => {
                    this.soundEnabled = !this.soundEnabled;
                    this.soundToggleBtn.textContent = this.soundEnabled ? 'üîä Sound' : 'üîá Muted';
                    if (this.soundEnabled && !this.musicPlaying) {
                        this.startMusic();
                    }
                });

                // Mobile touch controls
                const mobileJump = document.getElementById('mobileJump');
                const mobileLeft = document.getElementById('mobileLeft');
                const mobileRight = document.getElementById('mobileRight');
                const mobileBoost = document.getElementById('mobileBoost');

                if (mobileJump) {
                    mobileJump.addEventListener('touchstart', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                            setTimeout(() => {
                                try {
                                    if (this.gameState === 'waiting') {
                                        this.startGame();
                                    } else if (this.gameState === 'playing') {
                                        this.jump();
                                    }
                                } catch (error) {
                                    console.error('Error in mobile jump touchstart:', error);
                                }
                            }, 0);
                        } catch (error) {
                            console.error('Error in mobile jump handler:', error);
                        }
                    });
                    mobileJump.addEventListener('click', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                            setTimeout(() => {
                                try {
                                    if (this.gameState === 'waiting') {
                                        this.startGame();
                                    } else if (this.gameState === 'playing') {
                                        this.jump();
                                    }
                                } catch (error) {
                                    console.error('Error in mobile jump click:', error);
                                }
                            }, 0);
                        } catch (error) {
                            console.error('Error in mobile jump click handler:', error);
                        }
                    });
                }

                if (mobileLeft) {
                    mobileLeft.addEventListener('touchstart', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                            setTimeout(() => {
                                try {
                                    if (this.gameState === 'playing' && this.robot) {
                                        this.robot.x = Math.max(50, (this.robot.x || 0) - 8);
                                    }
                                } catch (error) {
                                    console.error('Error in mobile left touchstart:', error);
                                }
                            }, 0);
                        } catch (error) {
                            console.error('Error in mobile left handler:', error);
                        }
                    });
                    mobileLeft.addEventListener('touchmove', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (error) {
                            console.error('Error in mobile left touchmove:', error);
                        }
                    });
                    mobileLeft.addEventListener('touchend', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (error) {
                            console.error('Error in mobile left touchend:', error);
                        }
                    });
                }

                if (mobileRight) {
                    mobileRight.addEventListener('touchstart', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                            setTimeout(() => {
                                try {
                                    if (this.gameState === 'playing' && this.robot) {
                                        this.robot.x = Math.min(this.gameWidth - 50, (this.robot.x || 0) + 8);
                                    }
                                } catch (error) {
                                    console.error('Error in mobile right touchstart:', error);
                                }
                            }, 0);
                        } catch (error) {
                            console.error('Error in mobile right handler:', error);
                        }
                    });
                    mobileRight.addEventListener('touchmove', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (error) {
                            console.error('Error in mobile right touchmove:', error);
                        }
                    });
                    mobileRight.addEventListener('touchend', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (error) {
                            console.error('Error in mobile right touchend:', error);
                        }
                    });
                }

                if (mobileBoost) {
                    mobileBoost.addEventListener('touchstart', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                            setTimeout(() => {
                                try {
                                    if (this.gameState === 'playing' && this.rocketBoostStored > 0 && !this.rocketBoostActive) {
                                        this.activateRocketBoost();
                                    }
                                } catch (error) {
                                    console.error('Error in mobile boost touchstart:', error);
                                }
                            }, 0);
                        } catch (error) {
                            console.error('Error in mobile boost handler:', error);
                        }
                    });
                    mobileBoost.addEventListener('touchend', (e) => {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                            setTimeout(() => {
                                try {
                                    if (this.gameState === 'playing' && this.rocketBoostActive) {
                                        this.stopRocketBoost();
                                    }
                                } catch (error) {
                                    console.error('Error in mobile boost touchend:', error);
                                }
                            }, 0);
                        } catch (error) {
                            console.error('Error in mobile boost touchend handler:', error);
                        }
                    });
                }

                // Sound customization controls
                const musicVolumeSlider = document.getElementById('musicVolumeSlider');
                const soundVolumeSlider = document.getElementById('soundVolumeSlider');
                const soundEnabledCheckbox = document.getElementById('soundEnabledCheckbox');
                const musicVolumeValue = document.getElementById('musicVolumeValue');
                const soundVolumeValue = document.getElementById('soundVolumeValue');

                if (musicVolumeSlider) {
                    musicVolumeSlider.addEventListener('input', (e) => {
                        this.musicVolume = e.target.value / 100;
                        if (musicVolumeValue) {
                            musicVolumeValue.textContent = e.target.value;
                        }
                    });
                }

                if (soundVolumeSlider) {
                    soundVolumeSlider.addEventListener('input', (e) => {
                        this.soundEffectVolume = e.target.value / 100;
                        if (soundVolumeValue) {
                            soundVolumeValue.textContent = e.target.value;
                        }
                    });
                }

                if (soundEnabledCheckbox) {
                    soundEnabledCheckbox.addEventListener('change', (e) => {
                        this.soundEnabled = e.target.checked;
                        if (this.soundEnabled && !this.musicPlaying) {
                            this.startMusic();
                        } else if (!this.soundEnabled) {
                            this.musicPlaying = false;
                        }
                    });
                }

                // Settings menu buttons
                this.saveSettingsBtn.addEventListener('click', () => {
                    this.saveSettings();
                });

                this.closeSettingsBtn.addEventListener('click', () => {
                    this.closeSettings();
                });

                this.showLeaderboardBtn.addEventListener('click', () => {
                    this.showLeaderboard();
                });

                this.closeLeaderboardBtn.addEventListener('click', () => {
                    this.closeLeaderboard();
                });

                // Expand iframe button
                if (this.expandIframeBtn) {
                    this.expandIframeBtn.addEventListener('click', () => {
                        this.requestFullscreenExpansion();
                    });
                }

                // Multiplayer button in settings
                const showMultiplayerBtn = document.getElementById('showMultiplayer');
                if (showMultiplayerBtn) {
                    showMultiplayerBtn.addEventListener('click', () => {
                        console.log('Multiplayer button clicked');
                        this.showMultiplayerMenu();
                    });
                } else {
                    console.error('showMultiplayer button not found!');
                }

                // Background selection
                document.querySelectorAll('.bg-option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.bg-option').forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                        this.currentBackground = option.dataset.bg;
                    });
                });

                // Name input screen events
                this.playerNameInputMain.addEventListener('input', () => {
                    const name = this.playerNameInputMain.value.trim();
                    this.startGameBtn.disabled = name.length === 0;
                });

                this.playerNameInputMain.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.startGameBtn.disabled) {
                        this.startGameFromNameInput();
                    }
                });

                this.startGameBtn.addEventListener('click', () => {
                    this.startGameFromNameInput();
                });

                this.settingsBtnMain.addEventListener('click', () => {
                    this.showSettings();
                });

                // Level editor controls
                if (this.editorModeSelect) {
                    this.editorModeSelect.addEventListener('change', (e) => {
                        this.editorMode = e.target.value;
                    });
                }

                if (this.saveLevelBtn) {
                    this.saveLevelBtn.addEventListener('click', () => {
                        this.saveLevel();
                    });
                }

                if (this.loadLevelBtn) {
                    this.loadLevelBtn.addEventListener('click', () => {
                        this.loadLevel();
                    });
                }

                if (this.closeEditorBtn) {
                    this.closeEditorBtn.addEventListener('click', () => {
                        this.closeLevelEditor();
                    });
                }

                // Multiplayer controls
                if (this.createRoomBtn) {
                    this.createRoomBtn.addEventListener('click', () => {
                        this.createMultiplayerRoom();
                    });
                }

                if (this.joinRoomBtn) {
                    this.joinRoomBtn.addEventListener('click', () => {
                        this.joinMultiplayerRoom();
                    });
                }

                if (this.closeMultiplayerBtn) {
                    this.closeMultiplayerBtn.addEventListener('click', () => {
                        this.closeMultiplayerMenu();
                    });
                }

                // Level editor toggle (E key) and Multiplayer (M key)
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'KeyE' && this.gameState === 'playing') {
                        this.toggleLevelEditor();
                    }
                    // Allow M key from any state
                    if (e.code === 'KeyM' || e.key === 'm' || e.key === 'M') {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('M key pressed, opening multiplayer menu');
                        this.showMultiplayerMenu();
                    }
                }, true); // Use capture phase to catch the event early

                // Canvas click for level editor
                this.canvas.addEventListener('click', (e) => {
                    if (this.levelEditorActive) {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        this.placeEditorItem(x, y);
                    }
                });
            }

            startGame() {
                try {
                    this.gameState = 'playing';
                    // Clear any existing bosses and projectiles
                    this.currentBoss = null;
                    this.bossActive = false;
                    if (this.bosses) {
                        this.bosses = [];
                    }
                    // Clear all missiles (red dots) to prevent freezing
                    if (this.missiles) {
                        this.missiles = [];
                    }
                    if (this.instructionsElement) {
                        this.instructionsElement.style.display = 'none';
                    }
                    if (this.gameOverElement) {
                        this.gameOverElement.style.display = 'none';
                    }
                    if (this.nameInputScreen) {
                        this.nameInputScreen.style.display = 'none';
                    }
                    // Show mobile controls only when playing
                    this.updateMobileControlsVisibility();
                } catch (error) {
                    console.error('Error in startGame:', error);
                }
            }
            
            updateMobileControlsVisibility() {
                if (this.mobileControls) {
                    if (this.gameState === 'playing' && window.innerWidth <= 768) {
                        this.mobileControls.style.display = 'flex';
                    } else {
                        this.mobileControls.style.display = 'none';
                    }
                }
            }

            startGameFromNameInput() {
                const name = this.playerNameInputMain.value.trim();
                if (name.length > 0) {
                    this.playerName = name;
                    this.saveSettings();
                    this.hideNameInputScreen();
                    this.gameState = 'waiting';
                    this.instructionsElement.style.display = 'block';
                }
            }

            showNameInputScreen() {
                this.nameInputScreen.style.display = 'block';
                this.instructionsElement.style.display = 'none';
                this.gameOverElement.style.display = 'none';
                this.settingsMenu.style.display = 'none';
                this.leaderboard.style.display = 'none';
                this.playerNameInputMain.focus();
            }

            hideNameInputScreen() {
                this.nameInputScreen.style.display = 'none';
            }

            jump() {
                try {
                    if (!this.robot) {
                        console.error('Robot not initialized');
                        return;
                    }
                    if (typeof this.jumpForce !== 'number') {
                        console.error('Jump force not initialized');
                        return;
                    }
                    this.robot.velocity = this.jumpForce;
                    if (typeof this.playSound === 'function') {
                        this.playSound('jump');
                    }
                } catch (error) {
                    console.error('Error in jump function:', error);
                }
            }

            restart() {
                this.gameState = 'nameInput';
                // Clear any existing bosses and projectiles
                this.currentBoss = null;
                this.bossActive = false;
                if (this.bosses) {
                    this.bosses = [];
                }
                // Clear all missiles (red dots) to prevent freezing
                if (this.missiles) {
                    this.missiles = [];
                }
                // Hide mobile controls when restarting
                this.updateMobileControlsVisibility();
                this.score = 0;
                this.level = 1;
                this.obstacleSpeed = this.baseObstacleSpeed;
                this.obstacleInterval = 2500;
                this.robot = {
                    x: 100,
                    y: this.gameHeight / 2,
                    width: 45,
                    height: 35,
                    velocity: 0,
                    rotation: 0,
                    eyeGlow: 0
                };
                this.obstacles = [];
                this.coins = [];
                this.superCoins = [];
                this.rockets = [];
                this.rocketBoosts = [];
                this.missiles = [];
                this.shieldCount = 0;
                this.rocketActive = false;
                this.rocketTimeLeft = 0;
                this.rocketBoostStored = 0;
                this.rocketBoostActive = false;
                this.rocketBoostTimeLeft = 0;
                this.invincible = false;
                this.invincibleTimeLeft = 0;
                this.superCoinActive = false;
                this.superCoinTimeLeft = 0;
                this.player2Missiles = 0;
                this.player2Active = false; // Deactivate Player 2
                this.robotPower = 100;
                this.player1FirstCoinCollected = false; // Reset Player 2 lock
                this.lastProjectileHitTime = 0;
                this.lastBossHitTime = 0;
                this.hitProjectiles = new Set();
                this.obstaclesPassed = 0;
                this.bossModeEnabled = false;
                this.bossModePromptShown = false;
                this.scoreElement.textContent = '0';
                this.levelElement.textContent = 'Level 1';
                this.shieldCountElement.textContent = 'üõ°Ô∏è 0';
                this.invincibleTimeElement.style.display = 'none';
                this.rocketTimeElement.style.display = 'none';
                this.rocketBoostStoredElement.style.display = 'none';
                this.rocketBoostActiveElement.style.display = 'none';
                this.superCoinTimeElement.style.display = 'none';
                this.powerBarFill.style.width = '100%';
                this.player2StatusElement.textContent = 'Player 2: üîí Locked (collect first coin)';
                this.player2StatusElement.style.color = '#999';
                this.showNameInputScreen();
                this.closeAllMenus();
            }

            createClouds() {
                for (let i = 0; i < 5; i++) {
                    this.clouds.push({
                        x: Math.random() * this.gameWidth,
                        y: Math.random() * (this.gameHeight * 0.6),
                        size: Math.random() * 30 + 20,
                        speed: Math.random() * 0.5 + 0.2
                    });
                }
            }

            update() {
                if (this.gameState !== 'playing') return;
                
                // AGGRESSIVELY clear all missiles and magnets FIRST THING EVERY FRAME to prevent red dots
                this.missiles = [];
                this.magnets = [];
                
                // Track play time for achievements
                this.achievementStats.playTime = (this.achievementStats.playTime || 0) + 16; // Assuming 60fps
                this.checkStatAchievements();

                // Update robot
                this.robot.velocity += this.gravity;
                this.robot.y += this.robot.velocity;
                this.robot.rotation = Math.min(Math.max(this.robot.velocity * 3, -30), 30);
                this.robot.eyeGlow = Math.sin(Date.now() * 0.01) * 0.5 + 0.5; // Animate robot eyes

                // Update clouds
                this.clouds.forEach(cloud => {
                    cloud.x -= cloud.speed;
                    if (cloud.x < -cloud.size) {
                        cloud.x = this.gameWidth + cloud.size;
                        cloud.y = Math.random() * (this.gameHeight * 0.6);
                    }
                });

                // Generate obstacles
                const now = Date.now();
                if (now - this.lastObstacleTime > this.obstacleInterval) {
                    this.createObstacle();
                    this.lastObstacleTime = now;
                }

                // Boss mode completely disabled - no bosses will spawn
                // AGGRESSIVELY clear any existing bosses and projectiles EVERY FRAME
                this.currentBoss = null;
                this.bossActive = false;
                this.bosses = [];
                
                // AGGRESSIVELY clear all missiles EVERY FRAME to prevent red dots
                this.missiles = [];
                
                // Generate bosses - DISABLED
                // DISABLED: if (this.bossModeEnabled && !this.bossActive && now - this.lastBossSpawnTime > this.bossSpawnInterval) {
                //     this.spawnBoss();
                //     this.lastBossSpawnTime = now;
                // }

                // Update bosses - DISABLED
                // DISABLED: if (this.bossActive && this.currentBoss) {
                //     this.updateBoss();
                // }

                // Update obstacles
                let currentSpeed = this.obstacleSpeed;
                if (this.freezeActive) {
                    currentSpeed = 0; // Freeze obstacles
                } else if (this.rocketActive) {
                    currentSpeed = this.obstacleSpeed * this.rocketSpeedMultiplier; // Slow motion
                } else if (this.rocketBoostActive) {
                    currentSpeed = this.obstacleSpeed * this.rocketBoostSpeedMultiplier; // Speed boost
                }
                this.obstacles.forEach((obstacle, index) => {
                    obstacle.x -= currentSpeed;
                    if (obstacle.x < -this.obstacleWidth) {
                        this.obstacles.splice(index, 1);
                        // Track gates passed
                        this.obstaclesPassed++;
                        
                        // Only score if not invincible (robot must go through untouched)
                        if (!this.invincible) {
                            const points = this.doublePointsActive ? 2 : 1;
                            this.score += points;
                            this.scoreElement.textContent = this.score;
                            this.checkLevelUp();
                        }
                        
                        // Reduce coin lifetime when gate is passed (safe)
                        this.coins.forEach(coin => {
                            if (coin && !coin.collected && typeof coin.gatesRemaining === 'number') {
                                coin.gatesRemaining--;
                            }
                        });
                        
                        // Boss mode completely disabled - no prompt
                        // Check if 50 gates passed and show boss mode prompt
                        // DISABLED: if (this.obstaclesPassed === 50 && !this.bossModePromptShown) {
                        //     this.showBossModePrompt();
                        // }
                    }
                });

                // Update power-ups
                this.updatePowerUps();
                
                // Generate power-ups
                this.generatePowerUps();

                // Check collisions
                this.checkCollisions();
            }

            checkLevelUp() {
                const newLevel = Math.floor(this.score / this.pointsToNextLevel) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    this.levelElement.textContent = `Level ${this.level}`;
                    
                    // Increase difficulty
                    this.obstacleSpeed = this.baseObstacleSpeed + (this.level - 1) * 0.8;
                    this.obstacleInterval = Math.max(1500, 2500 - (this.level - 1) * 200);
                    
                    // Update music intensity
                    this.updateMusicIntensity();
                    
                    // Check level achievements
                    this.checkLevelAchievements();
                    
                    // Visual feedback for level up
                    this.showLevelUpEffect();
                }
            }

            showLevelUpEffect() {
                // Create a temporary level up effect
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#FFD700';
                effect.style.fontSize = '48px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = `LEVEL ${this.level}!`;
                effect.style.animation = 'fadeInOut 2s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 2000);
            }

            createObstacle() {
                // Ensure minimum gap size for playability, especially on mobile
                const minGap = 200;
                const currentGap = Math.max(this.obstacleGap, minGap);
                const availableHeight = this.gameHeight - currentGap - 100;
                
                if (availableHeight < 50) {
                    // If screen is too small, use a smaller gap but ensure it's still playable
                    const adjustedGap = Math.max(this.gameHeight * 0.3, 150);
                    const gapY = Math.random() * (this.gameHeight - adjustedGap - 50) + 25;
                    this.obstacles.push({
                        x: this.gameWidth,
                        topHeight: gapY,
                        bottomY: gapY + adjustedGap,
                        width: this.obstacleWidth
                    });
                } else {
                    const gapY = Math.random() * availableHeight + 50;
                    this.obstacles.push({
                        x: this.gameWidth,
                        topHeight: gapY,
                        bottomY: gapY + currentGap,
                        width: this.obstacleWidth
                    });
                }
            }

            checkCollisions() {
                try {
                    // Skip collision checks if invincible
                    if (this.invincible) {
                        this.checkPowerUpCollisions();
                        return;
                    }

                    // Safety check for robot
                    if (!this.robot || typeof this.robot.x !== 'number' || typeof this.robot.y !== 'number') {
                        return;
                    }

                    // Ground collision with barrier
                    if (this.robot.y + (this.robot.height || 20) > this.gameHeight - 50) {
                        if (this.shieldCount > 0) {
                            this.useShield();
                            // Bounce back up from the barrier
                            this.robot.y = this.gameHeight - 50 - (this.robot.height || 20) - 5;
                            this.robot.velocity = -8;
                            return;
                        }
                        this.gameOver();
                        return;
                    }

                    // Ceiling collision
                    if (this.robot.y < 0) {
                        if (this.shieldCount > 0) {
                            this.useShield();
                            return;
                        }
                        this.gameOver();
                        return;
                    }

                    // Obstacle collision (safe iteration)
                    for (let i = 0; i < this.obstacles.length; i++) {
                        const obstacle = this.obstacles[i];
                        if (!obstacle) continue;
                        
                        if (this.robot.x < obstacle.x + (obstacle.width || 50) &&
                            this.robot.x + (this.robot.width || 20) > obstacle.x) {
                            if (this.robot.y < (obstacle.topHeight || 0) ||
                                this.robot.y + (this.robot.height || 20) > (obstacle.bottomY || this.gameHeight)) {
                                if (this.shieldCount > 0) {
                                    this.useShield();
                                    return;
                                }
                                this.gameOver();
                                return;
                            }
                        }
                    }

                    // Power-up collisions
                    this.checkPowerUpCollisions();
                } catch (error) {
                    console.error('Error in checkCollisions:', error);
                    // Don't freeze the game - just log the error
                }
            }

            checkPowerUpCollisions() {
                // Check coin collisions (ultra-safe iteration)
                try {
                    const coinsToRemove = [];
                    const coinsToCollect = [];
                    
                    this.coins.forEach((coin, index) => {
                        if (coin && !coin.collected) {
                            // Safe distance calculation
                            const dx = (this.robot.x || 0) - (coin.x || 0);
                            const dy = (this.robot.y || 0) - (coin.y || 0);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const collisionDistance = (this.robot.width || 20) / 2 + (coin.size || 10);
                            
                            if (distance < collisionDistance) {
                                coin.collected = true;
                                coinsToCollect.push(coin);
                                coinsToRemove.push(index);
                            }
                        }
                    });
                    
                    // Process coin collections (deferred to prevent blocking)
                    if (coinsToCollect.length > 0) {
                        requestAnimationFrame(() => {
                            coinsToCollect.forEach(coin => {
                                this.collectCoin(coin);
                                this.player2Missiles++; // Player 2 gets missile for each shield
                            });
                        });
                    }
                    
                    // Remove collected coins after iteration
                    coinsToRemove.reverse().forEach(index => {
                        if (index >= 0 && index < this.coins.length) {
                            this.coins.splice(index, 1);
                        }
                    });
                    
                } catch (error) {
                    console.error('Error in coin collision detection:', error);
                    // Reset coins array if there's a critical error
                    this.coins = [];
                }

                // Check super coin collisions (safe iteration)
                try {
                    const superCoinsToRemove = [];
                    const superCoinsToCollect = [];
                    
                    this.superCoins.forEach((superCoin, index) => {
                        if (superCoin && !superCoin.collected) {
                            const dx = (this.robot.x || 0) - (superCoin.x || 0);
                            const dy = (this.robot.y || 0) - (superCoin.y || 0);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const collisionDistance = (this.robot.width || 20) / 2 + (superCoin.size || 30);
                            
                            if (distance < collisionDistance) {
                                superCoin.collected = true;
                                superCoinsToCollect.push(superCoin);
                                superCoinsToRemove.push(index);
                            }
                        }
                    });
                    
                    if (superCoinsToCollect.length > 0) {
                        setTimeout(() => {
                            try {
                                superCoinsToCollect.forEach(superCoin => {
                                    this.activateSuperCoin();
                                    if (typeof this.playSound === 'function') {
                                        this.playSound('superCoin');
                                    }
                                });
                            } catch (error) {
                                console.error('Error in super coin collection:', error);
                            }
                        }, 0);
                    }
                    
                    superCoinsToRemove.reverse().forEach(index => {
                        if (index >= 0 && index < this.superCoins.length) {
                            this.superCoins.splice(index, 1);
                        }
                    });
                } catch (error) {
                    console.error('Error in super coin collision detection:', error);
                }

                // Check rocket collisions (safe iteration)
                try {
                    const rocketsToRemove = [];
                    const rocketsToCollect = [];
                    
                    this.rockets.forEach((rocket, index) => {
                        if (rocket && !rocket.collected) {
                            // Safe distance calculation
                            const dx = (this.robot.x || 0) - (rocket.x || 0);
                            const dy = (this.robot.y || 0) - (rocket.y || 0);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const collisionDistance = (this.robot.width || 20) / 2 + (rocket.size || 25);
                            
                            if (distance < collisionDistance) {
                                rocket.collected = true;
                                rocketsToCollect.push(rocket);
                                rocketsToRemove.push(index);
                            }
                        }
                    });
                    
                    // Process rocket collections (deferred to prevent blocking)
                    if (rocketsToCollect.length > 0) {
                        setTimeout(() => {
                            try {
                                rocketsToCollect.forEach(rocket => {
                                    this.activateRocket();
                                    if (typeof this.playSound === 'function') {
                                        this.playSound('rocket');
                                    }
                                });
                            } catch (error) {
                                console.error('Error in rocket collection:', error);
                            }
                        }, 0);
                    }
                    
                    // Remove collected rockets after iteration
                    rocketsToRemove.reverse().forEach(index => {
                        if (index >= 0 && index < this.rockets.length) {
                            this.rockets.splice(index, 1);
                        }
                    });
                } catch (error) {
                    console.error('Error in rocket collision detection:', error);
                }

                // Check rocket boost collisions (safe iteration)
                try {
                    const boostsToRemove = [];
                    const boostsToCollect = [];
                    
                    this.rocketBoosts.forEach((boost, index) => {
                        if (boost && !boost.collected) {
                            // Safe distance calculation
                            const dx = (this.robot.x || 0) - (boost.x || 0);
                            const dy = (this.robot.y || 0) - (boost.y || 0);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const collisionDistance = (this.robot.width || 20) / 2 + (boost.size || 20);
                            
                            if (distance < collisionDistance) {
                                boost.collected = true;
                                boostsToCollect.push(boost);
                                boostsToRemove.push(index);
                            }
                        }
                    });
                    
                    // Process rocket boost collections (deferred to prevent blocking)
                    if (boostsToCollect.length > 0) {
                        setTimeout(() => {
                            try {
                                boostsToCollect.forEach(boost => {
                                    this.collectRocketBoost();
                                });
                            } catch (error) {
                                console.error('Error in rocket boost collection:', error);
                            }
                        }, 0);
                    }
                    
                    // Remove collected rocket boosts after iteration
                    boostsToRemove.reverse().forEach(index => {
                        if (index >= 0 && index < this.rocketBoosts.length) {
                            this.rocketBoosts.splice(index, 1);
                        }
                    });
                } catch (error) {
                    console.error('Error in rocket boost collision detection:', error);
                }

                // Check magnet collisions - DISABLED (magnets cause red dots)
                // Clear all magnets to prevent red dots
                this.magnets = [];
                // DISABLED: try {
                //     const magnetsToRemove = [];
                //     const magnetsToCollect = [];
                //     
                //     this.magnets.forEach((magnet, index) => {
                //         if (magnet && !magnet.collected) {
                //             const dx = (this.robot.x || 0) - (magnet.x || 0);
                //             const dy = (this.robot.y || 0) - (magnet.y || 0);
                //             const distance = Math.sqrt(dx * dx + dy * dy);
                //             const collisionDistance = (this.robot.width || 20) / 2 + (magnet.size || 22);
                //             
                //             if (distance < collisionDistance) {
                //                 magnet.collected = true;
                //                 magnetsToCollect.push(magnet);
                //                 magnetsToRemove.push(index);
                //             }
                //         }
                //     });
                //     
                //     if (magnetsToCollect.length > 0) {
                //         setTimeout(() => {
                //             try {
                //                 magnetsToCollect.forEach(magnet => {
                //                     this.activateMagnet();
                //                     if (typeof this.playSound === 'function') {
                //                         this.playSound('coin');
                //                     }
                //                 });
                //             } catch (error) {
                //                 console.error('Error in magnet collection:', error);
                //             }
                //         }, 0);
                //     }
                //     
                //     magnetsToRemove.reverse().forEach(index => {
                //         if (index >= 0 && index < this.magnets.length) {
                //             this.magnets.splice(index, 1);
                //         }
                //     });
                // } catch (error) {
                //     console.error('Error in magnet collision detection:', error);
                // }

                // Check freeze collisions (safe iteration)
                try {
                    const freezesToRemove = [];
                    const freezesToCollect = [];
                    
                    this.freezes.forEach((freeze, index) => {
                        if (freeze && !freeze.collected) {
                            const dx = (this.robot.x || 0) - (freeze.x || 0);
                            const dy = (this.robot.y || 0) - (freeze.y || 0);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const collisionDistance = (this.robot.width || 20) / 2 + (freeze.size || 24);
                            
                            if (distance < collisionDistance) {
                                freeze.collected = true;
                                freezesToCollect.push(freeze);
                                freezesToRemove.push(index);
                            }
                        }
                    });
                    
                    if (freezesToCollect.length > 0) {
                        setTimeout(() => {
                            try {
                                freezesToCollect.forEach(freeze => {
                                    this.activateFreeze();
                                    if (typeof this.playSound === 'function') {
                                        this.playSound('shield');
                                    }
                                });
                            } catch (error) {
                                console.error('Error in freeze collection:', error);
                            }
                        }, 0);
                    }
                    
                    freezesToRemove.reverse().forEach(index => {
                        if (index >= 0 && index < this.freezes.length) {
                            this.freezes.splice(index, 1);
                        }
                    });
                } catch (error) {
                    console.error('Error in freeze collision detection:', error);
                }

                // Check double points collisions (safe iteration)
                try {
                    const doublePointsToRemove = [];
                    const doublePointsToCollect = [];
                    
                    this.doublePoints.forEach((doublePoint, index) => {
                        if (doublePoint && !doublePoint.collected) {
                            const dx = (this.robot.x || 0) - (doublePoint.x || 0);
                            const dy = (this.robot.y || 0) - (doublePoint.y || 0);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const collisionDistance = (this.robot.width || 20) / 2 + (doublePoint.size || 26);
                            
                            if (distance < collisionDistance) {
                                doublePoint.collected = true;
                                doublePointsToCollect.push(doublePoint);
                                doublePointsToRemove.push(index);
                            }
                        }
                    });
                    
                    if (doublePointsToCollect.length > 0) {
                        setTimeout(() => {
                            try {
                                doublePointsToCollect.forEach(doublePoint => {
                                    this.activateDoublePoints();
                                    if (typeof this.playSound === 'function') {
                                        this.playSound('superCoin');
                                    }
                                });
                            } catch (error) {
                                console.error('Error in double points collection:', error);
                            }
                        }, 0);
                    }
                    
                    doublePointsToRemove.reverse().forEach(index => {
                        if (index >= 0 && index < this.doublePoints.length) {
                            this.doublePoints.splice(index, 1);
                        }
                    });
                } catch (error) {
                    console.error('Error in double points collision detection:', error);
                }

                // Check missile collisions - DISABLED (missiles cause red dots and freeze)
                // AGGRESSIVELY clear all missiles EVERY FRAME to prevent red dots
                this.missiles = [];
                if (this.missiles && this.missiles.length > 0) {
                    this.missiles = [];
                }
                // DISABLED: this.missiles.forEach((missile, index) => {
                //     const distance = Math.sqrt(
                //         Math.pow(this.robot.x - missile.x, 2) + 
                //         Math.pow(this.robot.y - missile.y, 2)
                //     );
                //     if (distance < (this.robot.width / 2 + missile.size)) {
                //         this.hitByMissile();
                //         this.missiles.splice(index, 1);
                //         this.playSound('damage');
                //     }
                // });
                
                // Check oil can collisions
                this.oilCans.forEach((oilCan, index) => {
                    const distance = Math.sqrt(
                        Math.pow(this.robot.x - oilCan.x, 2) + 
                        Math.pow(this.robot.y - oilCan.y, 2)
                    );
                    if (distance < (this.robot.width / 2 + oilCan.size)) {
                        this.collectOilCan();
                        this.oilCans.splice(index, 1);
                    }
                });
            }

            useShield() {
                this.shieldCount--;
                this.achievementStats.shieldsUsed = (this.achievementStats.shieldsUsed || 0) + 1;
                this.activateInvincibility();
                this.showShieldEffect();
                this.playSound('shield');
                this.checkStatAchievements();
            }
            
            collectCoin(coin) {
                try {
                    // Immediate, safe collection (no blocking operations)
                    this.shieldCount = (this.shieldCount || 0) + 1;
                    this.score = (this.score || 0) + 0.5;
                    
                    // Enable Player 2 after first coin is collected
                    if (!this.player1FirstCoinCollected) {
                        this.player1FirstCoinCollected = true;
                        console.log("Player 2 is now unlocked! Press P to activate.");
                    }
                    
                    // Update score immediately (safe operation)
                    if (this.scoreElement) {
                        this.scoreElement.textContent = `Score: ${Math.floor(this.score)}`;
                    }
                    
                    // Handle spending currency (safe)
                    if (coin && coin.rarity && coin.rarity.value) {
                        this.spendingCurrency = (this.spendingCurrency || 0) + coin.rarity.value;
                    } else {
                        this.spendingCurrency = (this.spendingCurrency || 0) + 1;
                    }
                    
                    // Update achievement stats
                    this.achievementStats.coinsCollected = (this.achievementStats.coinsCollected || 0) + 1;
                    this.achievementStats.powerUpsCollected = (this.achievementStats.powerUpsCollected || 0) + 1;
                    
                    // Defer ALL UI updates and effects to prevent blocking
                    setTimeout(() => {
                        try {
                            this.updateSpendingCurrency();
                            this.playSound('coin');
                            this.checkAchievement('firstCoin');
                            this.checkScoreAchievements();
                            this.checkStatAchievements();
                            
                            // Show coin effect (deferred)
                            if (coin && coin.rarity) {
                                this.showCoinEffect(coin.rarity);
                                
                                // Check for robot upgrade (deferred)
                                if (coin.rarity.name === 'Diamond') {
                                    this.robotUpgradeLevel = (this.robotUpgradeLevel || 0) + 1;
                                    if (this.robotUpgradeLevel >= 7) {
                                        this.upgradeRobot();
                                    }
                                }
                            } else {
                                this.showCoinEffect({ name: 'Gold', color: '#FFD700', value: 1 });
                            }
                        } catch (error) {
                            console.error('Error in deferred coin collection:', error);
                        }
                    }, 0);
                    
                } catch (error) {
                    console.error('Error in collectCoin:', error);
                    // Minimal fallback - just basic collection
                    this.shieldCount = (this.shieldCount || 0) + 1;
                    this.score = (this.score || 0) + 0.5;
                    if (this.scoreElement) {
                        this.scoreElement.textContent = `Score: ${Math.floor(this.score)}`;
                    }
                }
            }
            
            updateSpendingCurrency() {
                if (this.spendingCurrencyElement) {
                    this.spendingCurrencyElement.textContent = `üí∞ ${this.spendingCurrency || 0}`;
                } else {
                    console.warn('Spending currency element not found');
                }
            }

            activateInvincibility() {
                this.invincible = true;
                this.invincibleTimeLeft = 3000; // 3 seconds
                this.invincibleTimeElement.style.display = 'inline-block';
                this.showInvincibilityEffect();
            }

            activateRocket() {
                try {
                    this.rocketActive = true;
                    this.rocketTimeLeft = 3000; // 3 seconds
                    if (this.rocketTimeElement) {
                        this.rocketTimeElement.style.display = 'inline-block';
                    }
                    if (typeof this.showRocketEffect === 'function') {
                        this.showRocketEffect();
                    }
                    if (typeof this.showSlowMotionEffect === 'function') {
                        this.showSlowMotionEffect();
                    }
                    if (typeof this.checkAchievement === 'function') {
                        this.checkAchievement('firstRocket');
                    }
                } catch (error) {
                    console.error('Error in activateRocket:', error);
                    // Reset rocket state on error
                    this.rocketActive = false;
                    this.rocketTimeLeft = 0;
                }
            }

            activateRocketBoost() {
                // Activate boost from stored time
                if (this.rocketBoostStored > 0) {
                    this.rocketBoostActive = true;
                    this.rocketBoostTimeLeft = Math.min(this.rocketBoostStored, 3000); // Use stored time (max 3s)
                    this.rocketBoostStored = 0; // Clear stored boost
                    this.rocketBoostActiveElement.style.display = 'inline-block';
                    this.rocketBoostStoredElement.style.display = 'none';
                    this.achievementStats.rocketBoostsUsed = (this.achievementStats.rocketBoostsUsed || 0) + 1;
                    this.showRocketBoostEffect();
                    this.playSound('rocket');
                    this.checkStatAchievements();
                }
            }

            stopRocketBoost() {
                // Stop boost and save remaining time
                if (this.rocketBoostActive && this.rocketBoostTimeLeft > 0) {
                    // Save remaining time back to storage (can't stack, so replace)
                    this.rocketBoostStored = this.rocketBoostTimeLeft;
                    this.rocketBoostActive = false;
                    this.rocketBoostTimeLeft = 0;
                    this.rocketBoostActiveElement.style.display = 'none';
                    if (this.rocketBoostStored > 0) {
                        this.rocketBoostStoredElement.style.display = 'inline-block';
                        this.rocketBoostStoredElement.textContent = `‚ö° Boost: ${(this.rocketBoostStored / 1000).toFixed(1)}s`;
                    }
                }
            }

            collectRocketBoost() {
                // Collect rocket boost (max 3 seconds, can't stack)
                if (this.rocketBoostStored < 3000) {
                    this.rocketBoostStored = Math.min(3000, this.rocketBoostStored + 3000); // Add 3 seconds (max 3s total)
                    this.rocketBoostStoredElement.style.display = 'inline-block';
                    this.rocketBoostStoredElement.textContent = `‚ö° Boost: ${(this.rocketBoostStored / 1000).toFixed(1)}s`;
                    this.achievementStats.powerUpsCollected = (this.achievementStats.powerUpsCollected || 0) + 1;
                    this.showRocketBoostCollectEffect();
                    this.playSound('rocket');
                    this.checkAchievement('firstRocketBoost');
                    this.checkStatAchievements();
                }
            }

            showRocketBoostEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#FF6B6B';
                effect.style.fontSize = '32px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = '‚ö°‚ö° BOOST!';
                document.body.appendChild(effect);
                setTimeout(() => {
                    effect.style.transition = 'opacity 0.5s';
                    effect.style.opacity = '0';
                    setTimeout(() => effect.remove(), 500);
                }, 500);
            }

            showRocketBoostCollectEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#FFD700';
                effect.style.fontSize = '24px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = '‚ö° Rocket Boost Collected!';
                document.body.appendChild(effect);
                setTimeout(() => {
                    effect.style.transition = 'opacity 0.5s';
                    effect.style.opacity = '0';
                    setTimeout(() => effect.remove(), 500);
                }, 1000);
            }

            showShieldEffect() {
                // Create shield effect
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#3498DB';
                effect.style.fontSize = '32px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = 'üõ°Ô∏è SHIELD!';
                effect.style.animation = 'fadeInOut 1s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 1000);
            }

            showInvincibilityEffect() {
                // Create invincibility effect
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '60%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#9B59B6';
                effect.style.fontSize = '28px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = '‚ú® INVINCIBLE!';
                effect.style.animation = 'fadeInOut 1.5s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 1500);
            }

            showRocketEffect() {
                // Create rocket effect
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#E74C3C';
                effect.style.fontSize = '32px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = 'üöÄ ROCKET POWER!';
                effect.style.animation = 'fadeInOut 1.5s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 1500);
            }

            showSlowMotionEffect() {
                // Create slow motion effect
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '40%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#F39C12';
                effect.style.fontSize = '24px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = '‚è∞ SLOW MOTION!';
                effect.style.animation = 'fadeInOut 2s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 2000);
            }

            activateSuperCoin() {
                this.superCoinActive = true;
                this.superCoinTimeLeft = 5000; // 5 seconds
                this.superCoinTimeElement.style.display = 'inline-block';
                this.showSuperCoinEffect();
                this.checkAchievement('firstSuperCoin');
                
                // Generate plethora of coins
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.createCoin();
                    }, i * 200); // Staggered creation
                }
            }

            activateMagnet() {
                this.magnetActive = true;
                this.magnetTimeLeft = 5000; // 5 seconds
                this.achievementStats.powerUpsCollected = (this.achievementStats.powerUpsCollected || 0) + 1;
                this.showMagnetEffect();
                this.checkAchievement('firstMagnet');
                this.checkStatAchievements();
            }

            activateFreeze() {
                this.freezeActive = true;
                this.freezeTimeLeft = 4000; // 4 seconds
                this.achievementStats.powerUpsCollected = (this.achievementStats.powerUpsCollected || 0) + 1;
                this.showFreezeEffect();
                this.checkAchievement('firstFreeze');
                this.checkStatAchievements();
            }

            activateDoublePoints() {
                this.doublePointsActive = true;
                this.doublePointsTimeLeft = 10000; // 10 seconds
                this.achievementStats.powerUpsCollected = (this.achievementStats.powerUpsCollected || 0) + 1;
                this.showDoublePointsEffect();
                this.checkAchievement('firstDoublePoints');
                this.checkStatAchievements();
            }

            showMagnetEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#E74C3C';
                effect.style.fontSize = '32px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = 'üß≤ MAGNET!';
                document.body.appendChild(effect);
                setTimeout(() => {
                    effect.style.transition = 'opacity 0.5s';
                    effect.style.opacity = '0';
                    setTimeout(() => effect.remove(), 500);
                }, 500);
            }

            showFreezeEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#3498DB';
                effect.style.fontSize = '32px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = '‚ùÑÔ∏è FREEZE!';
                document.body.appendChild(effect);
                setTimeout(() => {
                    effect.style.transition = 'opacity 0.5s';
                    effect.style.opacity = '0';
                    setTimeout(() => effect.remove(), 500);
                }, 500);
            }

            showDoublePointsEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#F39C12';
                effect.style.fontSize = '32px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = '‚úñÔ∏è DOUBLE POINTS!';
                document.body.appendChild(effect);
                setTimeout(() => {
                    effect.style.transition = 'opacity 0.5s';
                    effect.style.opacity = '0';
                    setTimeout(() => effect.remove(), 500);
                }, 500);
            }

            showSuperCoinEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#F39C12';
                effect.style.fontSize = '36px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = '‚≠ê SUPER COIN!';
                effect.style.animation = 'fadeInOut 2s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 2000);
            }


            hitByMissile() {
                this.robotPower -= 10; // 10% damage
                if (this.robotPower <= 0) {
                    this.gameOver();
                } else {
                    this.showMissileHitEffect();
                }
            }
            
            collectOilCan() {
                // Restore 50% power (capped at 100%)
                this.robotPower = Math.min(100, this.robotPower + 50);
                this.showOilCanEffect();
                this.playSound('oilCan');
                this.checkAchievement('firstOilCan');
            }

            showMissileHitEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#E74C3C';
                effect.style.fontSize = '24px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = 'üí• HIT! -10%';
                effect.style.animation = 'fadeInOut 1s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 1000);
            }
            
            showOilCanEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#27AE60';
                effect.style.fontSize = '28px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = 'üõ¢Ô∏è +50% POWER!';
                effect.style.animation = 'fadeInOut 1.5s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 1500);
            }
            
            showCoinEffect(rarity) {
                // Safety check for rarity object
                if (!rarity || typeof rarity !== 'object') {
                    console.error('Invalid rarity object:', rarity);
                    return;
                }
                
                // Ensure required properties exist with defaults
                const safeRarity = {
                    color: rarity.color || '#FFD700',
                    value: rarity.value || 1,
                    name: rarity.name || 'Gold'
                };
                
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = safeRarity.color;
                effect.style.fontSize = (20 + (safeRarity.value * 2)) + 'px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = `ü™ô +${safeRarity.value} ${safeRarity.name}`;
                effect.style.animation = 'fadeInOut 1.2s ease-in-out';
                
                const gameContainer = document.getElementById('gameContainer');
                if (gameContainer) {
                    gameContainer.appendChild(effect);
                    
                    setTimeout(() => {
                        if (effect.parentNode) {
                            effect.parentNode.removeChild(effect);
                        }
                    }, 1200);
                } else {
                    console.error('Game container not found');
                }
            }
            
            checkAchievement(achievementKey) {
                if (!this.achievements[achievementKey]) {
                    this.achievements[achievementKey] = true;
                    this.addAchievementToBank(achievementKey);
                    this.updateAchievementBadges();
                }
            }
            
            checkScoreAchievements() {
                if (this.score >= 100 && !this.achievements.score100) {
                    this.checkAchievement('score100');
                }
                if (this.score >= 500 && !this.achievements.score500) {
                    this.checkAchievement('score500');
                }
                if (this.score >= 1000 && !this.achievements.score1000) {
                    this.checkAchievement('score1000');
                }
                if (this.score >= 2000 && !this.achievements.score2000) {
                    this.checkAchievement('score2000');
                }
                if (this.score >= 5000 && !this.achievements.score5000) {
                    this.checkAchievement('score5000');
                }
            }
            
            checkLevelAchievements() {
                if (this.level >= 5 && !this.achievements.level5) {
                    this.checkAchievement('level5');
                }
                if (this.level >= 10 && !this.achievements.level10) {
                    this.checkAchievement('level10');
                }
                if (this.level >= 20 && !this.achievements.level20) {
                    this.checkAchievement('level20');
                }
                if (this.level >= 30 && !this.achievements.level30) {
                    this.checkAchievement('level30');
                }
                if (this.level >= 50 && !this.achievements.level50) {
                    this.checkAchievement('level50');
                }
            }
            
            checkStatAchievements() {
                // Coin collector
                if (this.achievementStats.coinsCollected >= 50 && !this.achievements.coinCollector) {
                    this.checkAchievement('coinCollector');
                }
                // Power-up master
                if (this.achievementStats.powerUpsCollected >= 20 && !this.achievements.powerUpMaster) {
                    this.checkAchievement('powerUpMaster');
                }
                // Speed demon
                if (this.achievementStats.rocketBoostsUsed >= 10 && !this.achievements.speedDemon) {
                    this.checkAchievement('speedDemon');
                }
                // Invincible warrior
                if (this.achievementStats.shieldsUsed >= 20 && !this.achievements.invincibleWarrior) {
                    this.checkAchievement('invincibleWarrior');
                }
                // Boss slayer
                if (this.achievementStats.bossesDefeated >= 1 && !this.achievements.bossSlayer) {
                    this.checkAchievement('bossSlayer');
                }
                // Boss master
                if (this.achievementStats.bossesDefeated >= 5 && !this.achievements.bossMaster) {
                    this.checkAchievement('bossMaster');
                }
                // Survivalist
                if (this.achievementStats.playTime >= 300000 && !this.achievements.survivalist) { // 5 minutes
                    this.checkAchievement('survivalist');
                }
                // Marathon runner
                if (this.achievementStats.playTime >= 600000 && !this.achievements.marathonRunner) { // 10 minutes
                    this.checkAchievement('marathonRunner');
                }
            }
            
            addAchievementToBank(achievementKey) {
                const achievementNames = {
                    firstCoin: 'ü™ô First Coin',
                    firstRocket: 'üöÄ First Rocket',
                    firstOilCan: 'üõ¢Ô∏è First Oil',
                    firstSuperCoin: '‚≠ê First Super Coin',
                    firstMagnet: 'üß≤ First Magnet',
                    firstFreeze: '‚ùÑÔ∏è First Freeze',
                    firstDoublePoints: '‚úñÔ∏è First Double Points',
                    firstRocketBoost: '‚ö° First Rocket Boost',
                    level5: 'üèÜ Level 5',
                    level10: 'üëë Level 10',
                    level20: 'üíé Level 20',
                    level30: 'üí† Level 30',
                    level50: 'üëë Level 50',
                    score100: 'üíØ Score 100',
                    score500: 'üî• Score 500',
                    score1000: 'üåü Score 1000',
                    score2000: '‚≠ê Score 2000',
                    score5000: 'üí´ Score 5000',
                    perfectRun: '‚ú® Perfect Run',
                    missileMaster: 'üéØ Missile Master',
                    coinCollector: 'ü™ô Coin Collector (50)',
                    powerUpMaster: '‚ö° Power-Up Master (20)',
                    speedDemon: '‚ö° Speed Demon (10 boosts)',
                    invincibleWarrior: 'üõ°Ô∏è Invincible Warrior (20 shields)',
                    bossSlayer: 'üëπ Boss Slayer',
                    bossMaster: 'üëπ Boss Master (5)',
                    survivalist: '‚è±Ô∏è Survivalist (5 min)',
                    marathonRunner: 'üèÉ Marathon Runner (10 min)'
                };
                
                if (!this.achievementBankList) return;
                
                const achievementItem = document.createElement('div');
                achievementItem.className = 'achievement-bank-item';
                achievementItem.textContent = achievementNames[achievementKey] || 'üèÜ Achievement';
                
                this.achievementBankList.appendChild(achievementItem);
                
                // Auto-remove after 5 seconds to prevent overflow
                setTimeout(() => {
                    if (achievementItem.parentNode) {
                        achievementItem.parentNode.removeChild(achievementItem);
                    }
                }, 5000);
                
                // Play achievement sound (non-blocking)
                this.playSound('coin'); // Use existing coin sound for achievements
            }
            
            updateAchievementBadges() {
                if (!this.achievementBadgesElement) return;
                
                this.achievementBadgesElement.innerHTML = '';
                
                const badgeOrder = [
                    'firstCoin', 'firstRocket', 'firstOilCan', 'firstSuperCoin',
                    'level5', 'level10', 'level20',
                    'score100', 'score500', 'score1000',
                    'perfectRun', 'missileMaster'
                ];
                
                badgeOrder.forEach(achievementKey => {
                    if (this.achievements[achievementKey]) {
                        const badge = document.createElement('div');
                        badge.className = 'achievement-badge';
                        badge.textContent = this.getAchievementBadgeText(achievementKey);
                        this.achievementBadgesElement.appendChild(badge);
                    }
                });
            }
            
            getAchievementBadgeText(achievementKey) {
                const badgeTexts = {
                    firstCoin: 'ü™ô',
                    firstRocket: 'üöÄ',
                    firstOilCan: 'üõ¢Ô∏è',
                    firstSuperCoin: '‚≠ê',
                    level5: '5Ô∏è‚É£',
                    level10: 'üîü',
                    level20: '2Ô∏è‚É£0Ô∏è‚É£',
                    score100: 'üíØ',
                    score500: 'üî•',
                    score1000: 'üåü',
                    perfectRun: '‚ú®',
                    missileMaster: 'üéØ'
                };
                return badgeTexts[achievementKey] || 'üèÜ';
            }
            
            upgradeRobot() {
                this.robotUpgradeLevel = 0; // Reset for next upgrade cycle
                this.showRobotUpgradeEffect();
                this.playSound('superCoin'); // Use special sound for upgrade
            }
            
            showRobotUpgradeEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#FFD700';
                effect.style.fontSize = '32px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = 'ü§ñ ROBOT UPGRADED! ü§ñ';
                effect.style.animation = 'fadeInOut 3s ease-in-out';
                
                document.getElementById('gameContainer').appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 3000);
            }
            
            getCoinSymbol(rarityName) {
                if (!rarityName || typeof rarityName !== 'string') {
                    return '$';
                }
                
                const symbols = {
                    'Bronze': 'B',
                    'Silver': 'S',
                    'Gold': 'G',
                    'Emerald': 'E',
                    'Sapphire': 'S',
                    'Ruby': 'R',
                    'Diamond': 'D'
                };
                return symbols[rarityName] || '$';
            }
            
            lightenColor(color, factor) {
                // Safety checks
                if (!color || typeof color !== 'string') {
                    return '#FFD700'; // Default gold color
                }
                
                if (typeof factor !== 'number' || factor < 0 || factor > 1) {
                    factor = 0.3; // Default factor
                }
                
                try {
                    // Convert hex to RGB
                    const hex = color.replace('#', '');
                    if (hex.length !== 6) {
                        return '#FFD700'; // Default if invalid hex
                    }
                    
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    
                    // Check for valid RGB values
                    if (isNaN(r) || isNaN(g) || isNaN(b)) {
                        return '#FFD700'; // Default if invalid
                    }
                    
                    // Lighten by factor
                    const newR = Math.min(255, Math.floor(r + (255 - r) * factor));
                    const newG = Math.min(255, Math.floor(g + (255 - g) * factor));
                    const newB = Math.min(255, Math.floor(b + (255 - b) * factor));
                    
                    // Convert back to hex
                    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
                } catch (error) {
                    console.error('Error in lightenColor:', error);
                    return '#FFD700'; // Default fallback
                }
            }

            gameOver() {
                this.gameState = 'gameOver';
                // Hide mobile controls when game over
                this.updateMobileControlsVisibility();
                this.finalScoreElement.textContent = `Score: ${this.score} | Level: ${this.level}`;
                this.gameOverElement.style.display = 'block';
                this.saveScore();
                this.playSound('gameOver');
            }

            // Settings and UI Management
            loadSettings() {
                const savedSettings = localStorage.getItem('intheair_settings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    this.playerName = settings.playerName || 'Player';
                    this.currentBackground = settings.background || 'day';
                    this.musicVolume = settings.musicVolume !== undefined ? settings.musicVolume : 0.3;
                    this.soundEffectVolume = settings.soundEffectVolume !== undefined ? settings.soundEffectVolume : 0.4;
                    this.soundEnabled = settings.soundEnabled !== undefined ? settings.soundEnabled : true;
                    
                    // Update UI sliders
                    const musicVolumeSlider = document.getElementById('musicVolumeSlider');
                    const soundVolumeSlider = document.getElementById('soundVolumeSlider');
                    const soundEnabledCheckbox = document.getElementById('soundEnabledCheckbox');
                    const musicVolumeValue = document.getElementById('musicVolumeValue');
                    const soundVolumeValue = document.getElementById('soundVolumeValue');
                    
                    if (musicVolumeSlider) musicVolumeSlider.value = this.musicVolume * 100;
                    if (soundVolumeSlider) soundVolumeSlider.value = this.soundEffectVolume * 100;
                    if (soundEnabledCheckbox) soundEnabledCheckbox.checked = this.soundEnabled;
                    if (musicVolumeValue) musicVolumeValue.textContent = Math.round(this.musicVolume * 100);
                    if (soundVolumeValue) soundVolumeValue.textContent = Math.round(this.soundEffectVolume * 100);
                    
                    // If we have a saved name, skip name input screen
                    if (this.playerName !== 'Player') {
                        this.gameState = 'waiting';
                    }
                }
            }

            saveSettings() {
                const settings = {
                    playerName: this.playerName,
                    background: this.currentBackground,
                    musicVolume: this.musicVolume,
                    soundEffectVolume: this.soundEffectVolume,
                    soundEnabled: this.soundEnabled
                };
                
                localStorage.setItem('intheair_settings', JSON.stringify(settings));
                this.updateUI();
                this.closeSettings();
            }

            // Save/Load Game States
            saveGameState() {
                const gameState = {
                    score: this.score,
                    level: this.level,
                    shieldCount: this.shieldCount,
                    robotPower: this.robotPower,
                    robotUpgradeLevel: this.robotUpgradeLevel,
                    spendingCurrency: this.spendingCurrency,
                    achievements: this.achievements,
                    robot: {
                        x: this.robot.x,
                        y: this.robot.y,
                        velocity: this.robot.velocity
                    },
                    timestamp: Date.now()
                };
                
                localStorage.setItem('robot_lyric_game_state', JSON.stringify(gameState));
                console.log('Game state saved!');
            }

            loadGameState() {
                const savedState = localStorage.getItem('robot_lyric_game_state');
                if (!savedState) return false;
                
                try {
                    const gameState = JSON.parse(savedState);
                    
                    // Check if save is too old (more than 1 hour)
                    const age = Date.now() - gameState.timestamp;
                    if (age > 3600000) {
                        localStorage.removeItem('robot_lyric_game_state');
                        return false;
                    }
                    
                    // Restore game state
                    this.score = gameState.score || 0;
                    this.level = gameState.level || 1;
                    this.shieldCount = gameState.shieldCount || 0;
                    this.robotPower = gameState.robotPower || 100;
                    this.robotUpgradeLevel = gameState.robotUpgradeLevel || 0;
                    this.spendingCurrency = gameState.spendingCurrency || 0;
                    this.achievements = { ...this.achievements, ...(gameState.achievements || {}) };
                    
                    if (gameState.robot) {
                        this.robot.x = gameState.robot.x || this.robot.x;
                        this.robot.y = gameState.robot.y || this.robot.y;
                        this.robot.velocity = gameState.robot.velocity || 0;
                    }
                    
                    this.updateUI();
                    console.log('Game state loaded!');
                    return true;
                } catch (e) {
                    console.error('Failed to load game state:', e);
                    return false;
                }
            }

            autoSave() {
                // Auto-save every 30 seconds during gameplay
                if (this.gameState === 'playing') {
                    this.saveGameState();
                }
            }

            showSettings() {
                document.querySelectorAll('.bg-option').forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.dataset.bg === this.currentBackground) {
                        opt.classList.add('selected');
                    }
                });
                if (this.settingsMenu) {
                    this.settingsMenu.style.display = 'block';
                }
                // Close other menus
                if (this.leaderboard) {
                    this.leaderboard.style.display = 'none';
                }
                if (this.multiplayerMenuElement) {
                    this.multiplayerMenuElement.style.display = 'none';
                }
                // Don't change game state - just show settings
            }

            closeSettings() {
                this.settingsMenu.style.display = 'none';
            }

            showLeaderboard() {
                this.updateLeaderboard();
                this.leaderboard.style.display = 'block';
                this.leaderboard.style.zIndex = '1001';
                // Close settings menu when opening leaderboard
                if (this.settingsMenu) {
                    this.settingsMenu.style.display = 'none';
                }
            }

            closeLeaderboard() {
                this.leaderboard.style.display = 'none';
            }

            setupIframeCommunication() {
                // Listen for messages from parent window
                window.addEventListener('message', (event) => {
                    // Verify origin for security (adjust as needed)
                    // if (event.origin !== 'https://yourdomain.com') return;
                    
                    if (event.data && event.data.type === 'iframe-resize') {
                        // Handle iframe resize requests from parent
                        this.handleIframeResize(event.data);
                    }
                });

                // Notify parent that game is ready
                if (this.isInIframe) {
                    try {
                        window.parent.postMessage({
                            type: 'game-ready',
                            game: 'robot-lyric'
                        }, '*');
                    } catch (e) {
                        console.log('Could not communicate with parent window');
                    }
                }
            }

            requestFullscreenExpansion() {
                if (this.isInIframe) {
                    try {
                        window.parent.postMessage({
                            type: 'request-fullscreen',
                            game: 'robot-lyric',
                            url: window.location.href
                        }, '*');
                    } catch (e) {
                        console.log('Could not request fullscreen expansion');
                    }
                }
            }

            handleIframeResize(data) {
                // Handle resize requests if needed
                if (data.width && data.height) {
                    // Adjust game canvas if needed
                }
            }

            closeAllMenus() {
                this.closeSettings();
                this.closeLeaderboard();
            }

            updateUI() {
                this.playerNameElement.textContent = this.playerName;
                this.updateTextColors();
            }

            updateTextColors() {
                const textColor = this.backgrounds[this.currentBackground].textColor;
                this.scoreElement.style.color = textColor;
                this.levelElement.style.color = textColor;
                this.playerNameElement.style.color = textColor;
            }

            saveScore() {
                const scores = this.getScores();
                scores.push({
                    name: this.playerName,
                    score: this.score,
                    level: this.level,
                    date: new Date().toISOString()
                });
                
                // Sort by score (descending) and keep top 10
                scores.sort((a, b) => b.score - a.score);
                const topScores = scores.slice(0, 10);
                
                localStorage.setItem('intheair_scores', JSON.stringify(topScores));
            }

            getScores() {
                const savedScores = localStorage.getItem('intheair_scores');
                return savedScores ? JSON.parse(savedScores) : [];
            }

            updateLeaderboard() {
                const scores = this.getScores();
                this.leaderboardList.innerHTML = '';
                
                if (scores.length === 0) {
                    this.leaderboardList.innerHTML = '<p>No scores yet. Be the first to play!</p>';
                    return;
                }
                
                scores.forEach((entry, index) => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'leaderboard-entry';
                    if (entry.name === this.playerName) {
                        entryDiv.classList.add('current-player');
                    }
                    
                    entryDiv.innerHTML = `
                        <div class="rank">#${index + 1}</div>
                        <div class="player-name">${entry.name}</div>
                        <div class="score">${entry.score}</div>
                        <div class="level">L${entry.level}</div>
                    `;
                    
                    this.leaderboardList.appendChild(entryDiv);
                });
            }

            // Power-up Systems
            generatePowerUps() {
                const now = Date.now();
                
                // Generate coins (reduced frequency)
                if (now - this.lastCoinTime > this.coinInterval) {
                    this.createCoin();
                    this.lastCoinTime = now;
                }
                
                // Generate super coins (rare)
                if (now - this.lastSuperCoinTime > this.superCoinInterval) {
                    this.createSuperCoin();
                    this.lastSuperCoinTime = now;
                }
                
                // Generate oil cans (health restoration)
                if (now - this.lastOilCanTime > this.oilCanInterval) {
                    this.createOilCan();
                    this.lastOilCanTime = now;
                }
                
                // Generate rockets
                if (now - this.lastRocketTime > this.rocketInterval) {
                    this.createRocket();
                    this.lastRocketTime = now;
                }
                
                // Generate rocket boosts
                if (now - this.lastRocketBoostTime > this.rocketBoostInterval) {
                    this.createRocketBoost();
                    this.lastRocketBoostTime = now;
                }
                
                // Generate magnets - DISABLED (magnets cause red dots)
                // MAGNETS DISABLED - NO RED DOTS
                // if (now - this.lastMagnetTime > this.magnetInterval) {
                //     this.createMagnet();
                //     this.lastMagnetTime = now;
                // }
                
                // Generate freezes
                if (now - this.lastFreezeTime > this.freezeInterval) {
                    this.createFreeze();
                    this.lastFreezeTime = now;
                }
                
                // Generate double points
                if (now - this.lastDoublePointsTime > this.doublePointsInterval) {
                    this.createDoublePoints();
                    this.lastDoublePointsTime = now;
                }
            }

            createCoin() {
                // Select coin rarity based on probability
                const random = Math.random();
                let cumulativeRarity = 0;
                let selectedRarity = this.coinRarities[0]; // Default to bronze
                
                for (const rarity of this.coinRarities) {
                    cumulativeRarity += rarity.rarity;
                    if (random <= cumulativeRarity) {
                        selectedRarity = rarity;
                        break;
                    }
                }
                
                this.coins.push({
                    x: Math.random() * (this.gameWidth - 100) + 50,
                    y: Math.random() * (this.gameHeight - 200) + 100,
                    size: 15 + (selectedRarity.value * 2), // Larger coins for higher rarity
                    velocity: {
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2
                    },
                    rotation: 0,
                    collected: false,
                    rarity: selectedRarity,
                    gatesRemaining: selectedRarity.lifetime,
                    glowPhase: 0
                });
            }

            createSuperCoin() {
                this.superCoins.push({
                    x: Math.random() * (this.gameWidth - 100) + 50,
                    y: Math.random() * (this.gameHeight - 200) + 100,
                    size: 30,
                    velocity: {
                        x: (Math.random() - 0.5) * 1,
                        y: (Math.random() - 0.5) * 1
                    },
                    rotation: 0,
                    collected: false,
                    glow: 0
                });
            }
            
            createOilCan() {
                this.oilCans.push({
                    x: Math.random() * (this.gameWidth - 40) + 20,
                    y: Math.random() * (this.gameHeight - 200) + 100,
                    size: 20,
                    velocity: {
                        x: (Math.random() - 0.5) * 1.5,
                        y: (Math.random() - 0.5) * 1.5
                    },
                    rotation: 0,
                    bobPhase: 0
                });
            }

            createRocket() {
                this.rockets.push({
                    x: Math.random() * (this.gameWidth - 100) + 50,
                    y: Math.random() * (this.gameHeight - 200) + 100,
                    size: 25,
                    velocity: {
                        x: (Math.random() - 0.5) * 1.5,
                        y: (Math.random() - 0.5) * 1.5
                    },
                    rotation: 0,
                    collected: false
                });
            }

            createRocketBoost() {
                this.rocketBoosts.push({
                    x: Math.random() * (this.gameWidth - 100) + 50,
                    y: Math.random() * (this.gameHeight - 200) + 100,
                    size: 20,
                    velocity: {
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2
                    },
                    rotation: 0,
                    collected: false,
                    glow: 0
                });
            }


            createFreeze() {
                this.freezes.push({
                    x: Math.random() * (this.gameWidth - 100) + 50,
                    y: Math.random() * (this.gameHeight - 200) + 100,
                    size: 24,
                    velocity: {
                        x: (Math.random() - 0.5) * 1.5,
                        y: (Math.random() - 0.5) * 1.5
                    },
                    rotation: 0,
                    collected: false,
                    glow: 0
                });
            }

            createDoublePoints() {
                this.doublePoints.push({
                    x: Math.random() * (this.gameWidth - 100) + 50,
                    y: Math.random() * (this.gameHeight - 200) + 100,
                    size: 26,
                    velocity: {
                        x: (Math.random() - 0.5) * 1.5,
                        y: (Math.random() - 0.5) * 1.5
                    },
                    rotation: 0,
                    collected: false,
                    glow: 0
                });
            }


            damageBoss(damage) {
                if (!this.bossActive || !this.currentBoss) return;
                
                this.bossHealth -= damage;
                if (this.bossHealth <= 0) {
                    this.defeatBoss();
                } else {
                    this.showBossDamage(damage);
                }
            }

            defeatBoss() {
                this.bossActive = false;
                this.achievementStats.bossesDefeated = (this.achievementStats.bossesDefeated || 0) + 1;
                this.score += 50;
                this.showBossDefeatEffect();
                this.playSound('superCoin');
                this.checkAchievement('bossSlayer');
                this.checkStatAchievements();
                this.currentBoss = null;
            }

            showBossModePrompt() {
                this.bossModePromptShown = true;
                
                const prompt = document.createElement('div');
                prompt.style.position = 'fixed';
                prompt.style.top = '50%';
                prompt.style.left = '50%';
                prompt.style.transform = 'translate(-50%, -50%)';
                prompt.style.background = 'rgba(0, 0, 0, 0.95)';
                prompt.style.color = 'white';
                prompt.style.padding = '30px';
                prompt.style.borderRadius = '15px';
                prompt.style.border = '3px solid #F1C40F';
                prompt.style.zIndex = '2000';
                prompt.style.pointerEvents = 'auto';
                prompt.style.textAlign = 'center';
                prompt.style.minWidth = '300px';
                prompt.style.maxWidth = '90vw';
                
                prompt.innerHTML = `
                    <h2 style="margin: 0 0 15px 0; color: #F1C40F; font-size: 28px;">üéØ 50 Gates Passed!</h2>
                    <p style="margin: 0 0 20px 0; font-size: 18px;">Enable Boss Mode for Double Points?</p>
                    <p style="margin: 0 0 20px 0; font-size: 14px; color: #95A5A6;">Boss battles will spawn and give 2x points!</p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button id="enableBossMode" style="padding: 12px 24px; background: #27AE60; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚úÖ Enable</button>
                        <button id="disableBossMode" style="padding: 12px 24px; background: #E74C3C; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚ùå Disable</button>
                    </div>
                `;
                
                document.body.appendChild(prompt);
                
                const enableBtn = prompt.querySelector('#enableBossMode');
                const disableBtn = prompt.querySelector('#disableBossMode');
                
                enableBtn.addEventListener('click', () => {
                    this.bossModeEnabled = true;
                    this.doublePointsActive = true; // Enable double points with boss mode
                    prompt.remove();
                    this.playSound('superCoin');
                    
                    // Show confirmation
                    const confirm = document.createElement('div');
                    confirm.style.position = 'fixed';
                    confirm.style.top = '20%';
                    confirm.style.left = '50%';
                    confirm.style.transform = 'translateX(-50%)';
                    confirm.style.color = '#27AE60';
                    confirm.style.fontSize = '32px';
                    confirm.style.fontWeight = 'bold';
                    confirm.style.textShadow = '2px 2px 4px rgba(0,0,0,0.9)';
                    confirm.style.zIndex = '2000';
                    confirm.style.pointerEvents = 'none';
                    confirm.textContent = 'üëπ Boss Mode Enabled! 2x Points!';
                    document.body.appendChild(confirm);
                    setTimeout(() => {
                        confirm.style.transition = 'opacity 1s';
                        confirm.style.opacity = '0';
                        setTimeout(() => confirm.remove(), 1000);
                    }, 2000);
                });
                
                disableBtn.addEventListener('click', () => {
                    this.bossModeEnabled = false;
                    prompt.remove();
                    this.playSound('jump');
                });
            }

            showBossWarning() {
                const warning = document.createElement('div');
                warning.style.position = 'absolute';
                warning.style.top = '20%';
                warning.style.left = '50%';
                warning.style.transform = 'translateX(-50%)';
                warning.style.color = '#E74C3C';
                warning.style.fontSize = '48px';
                warning.style.fontWeight = 'bold';
                warning.style.textShadow = '3px 3px 6px rgba(0,0,0,0.9)';
                warning.style.zIndex = '1000';
                warning.style.pointerEvents = 'none';
                warning.textContent = 'üëπ BOSS INCOMING! üëπ';
                document.body.appendChild(warning);
                setTimeout(() => {
                    warning.style.transition = 'opacity 1s';
                    warning.style.opacity = '0';
                    setTimeout(() => warning.remove(), 1000);
                }, 2000);
            }

            showBossDamage(damage) {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#E74C3C';
                effect.style.fontSize = '24px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = `üí• -${damage}`;
                document.body.appendChild(effect);
                setTimeout(() => {
                    effect.style.transition = 'opacity 0.5s';
                    effect.style.opacity = '0';
                    setTimeout(() => effect.remove(), 500);
                }, 500);
            }

            showBossDefeatEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#FFD700';
                effect.style.fontSize = '48px';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '3px 3px 6px rgba(0,0,0,0.9)';
                effect.style.zIndex = '1000';
                effect.style.pointerEvents = 'none';
                effect.textContent = 'üëπ BOSS DEFEATED! +50';
                document.body.appendChild(effect);
                setTimeout(() => {
                    effect.style.transition = 'opacity 1s';
                    effect.style.opacity = '0';
                    setTimeout(() => effect.remove(), 1000);
                }, 2000);
            }


            // Level Editor System
            toggleLevelEditor() {
                this.levelEditorActive = !this.levelEditorActive;
                if (this.levelEditorElement) {
                    this.levelEditorElement.style.display = this.levelEditorActive ? 'block' : 'none';
                }
            }

            placeEditorItem(x, y) {
                if (!this.levelEditorActive) return;
                
                switch(this.editorMode) {
                    case 'obstacle':
                        this.editorObstacles.push({
                            x: x,
                            y: y,
                            width: this.obstacleWidth,
                            topHeight: 100,
                            bottomY: this.gameHeight - 100
                        });
                        break;
                    case 'coin':
                        this.coins.push({
                            x: x,
                            y: y,
                            size: 15,
                            velocity: { x: 0, y: 0 },
                            rotation: 0,
                            collected: false,
                            rarity: this.coinRarities[2], // Gold
                            gatesRemaining: 20,
                            glowPhase: 0
                        });
                        break;
                    case 'powerup':
                        // Random power-up
                        const powerUps = ['rocket', 'magnet', 'freeze', 'doublePoints'];
                        const randomPowerUp = powerUps[Math.floor(Math.random() * powerUps.length)];
                        if (randomPowerUp === 'rocket') {
                            this.rockets.push({
                                x: x,
                                y: y,
                                size: 25,
                                velocity: { x: 0, y: 0 },
                                rotation: 0,
                                collected: false
                            });
                        } else if (randomPowerUp === 'magnet') {
                            // MAGNETS DISABLED - NO RED DOTS
                            // this.magnets.push({
                            //     x: x,
                            //     y: y,
                            //     size: 22,
                            //     velocity: { x: 0, y: 0 },
                            //     rotation: 0,
                            //     collected: false,
                            //     glow: 0
                            // });
                        } else if (randomPowerUp === 'freeze') {
                            this.freezes.push({
                                x: x,
                                y: y,
                                size: 24,
                                velocity: { x: 0, y: 0 },
                                rotation: 0,
                                collected: false,
                                glow: 0
                            });
                        } else if (randomPowerUp === 'doublePoints') {
                            this.doublePoints.push({
                                x: x,
                                y: y,
                                size: 26,
                                velocity: { x: 0, y: 0 },
                                rotation: 0,
                                collected: false,
                                glow: 0
                            });
                        }
                        break;
                }
            }

            saveLevel() {
                const levelData = {
                    obstacles: this.editorObstacles,
                    coins: this.coins.filter(c => !c.collected),
                    powerUps: {
                        rockets: this.rockets.filter(r => !r.collected),
                        magnets: this.magnets.filter(m => !m.collected),
                        freezes: this.freezes.filter(f => !f.collected),
                        doublePoints: this.doublePoints.filter(d => !d.collected)
                    },
                    name: `Level ${this.savedLevels.length + 1}`,
                    timestamp: Date.now()
                };
                
                this.savedLevels.push(levelData);
                localStorage.setItem('robot_lyric_levels', JSON.stringify(this.savedLevels));
                alert(`Level saved! Total levels: ${this.savedLevels.length}`);
            }

            loadLevel() {
                const savedLevels = localStorage.getItem('robot_lyric_levels');
                if (!savedLevels) {
                    alert('No saved levels found!');
                    return;
                }
                
                this.savedLevels = JSON.parse(savedLevels);
                if (this.savedLevels.length === 0) {
                    alert('No saved levels found!');
                    return;
                }
                
                // Load the most recent level
                const level = this.savedLevels[this.savedLevels.length - 1];
                this.editorObstacles = level.obstacles || [];
                // Note: In a full implementation, you'd load obstacles into the game
                alert(`Loaded: ${level.name}`);
            }

            closeLevelEditor() {
                this.levelEditorActive = false;
                if (this.levelEditorElement) {
                    this.levelEditorElement.style.display = 'none';
                }
            }

            // Multiplayer System
            showMultiplayerMenu() {
                console.log('showMultiplayerMenu called');
                console.log('multiplayerMenuElement:', this.multiplayerMenuElement);
                if (this.multiplayerMenuElement) {
                    this.multiplayerMenuElement.style.display = 'block';
                    console.log('Multiplayer menu displayed');
                    // Close other menus
                    if (this.settingsMenu) {
                        this.settingsMenu.style.display = 'none';
                    }
                    if (this.leaderboard) {
                        this.leaderboard.style.display = 'none';
                    }
                    if (this.levelEditorElement) {
                        this.levelEditorElement.style.display = 'none';
                    }
                    if (this.nameInputScreen) {
                        this.nameInputScreen.style.display = 'none';
                    }
                    if (this.gameOverElement) {
                        this.gameOverElement.style.display = 'none';
                    }
                } else {
                    console.error('Multiplayer menu element not found!');
                    // Try to find it again
                    this.multiplayerMenuElement = document.getElementById('multiplayerMenu');
                    if (this.multiplayerMenuElement) {
                        console.log('Found multiplayer menu element on retry');
                        this.showMultiplayerMenu();
                    }
                }
            }

            closeMultiplayerMenu() {
                if (this.multiplayerMenuElement) {
                    this.multiplayerMenuElement.style.display = 'none';
                }
            }

            createMultiplayerRoom() {
                // Generate room ID
                this.roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
                this.isHost = true;
                
                if (this.roomStatusElement) {
                    this.roomStatusElement.textContent = `Room ID: ${this.roomId} - Waiting for player...`;
                    this.roomStatusElement.style.color = '#2ECC71';
                }
                
                // Initialize WebRTC (simplified - would use PeerJS or similar in production)
                this.initMultiplayer();
            }

            joinMultiplayerRoom() {
                const roomId = this.roomIdInput.value.trim().toUpperCase();
                if (!roomId) {
                    alert('Please enter a room ID');
                    return;
                }
                
                this.roomId = roomId;
                this.isHost = false;
                
                if (this.roomStatusElement) {
                    this.roomStatusElement.textContent = `Joining room: ${roomId}...`;
                    this.roomStatusElement.style.color = '#3498DB';
                }
                
                // Initialize WebRTC connection
                this.initMultiplayer();
            }

            initMultiplayer() {
                // Simplified multiplayer initialization
                // In production, use PeerJS or WebSocket server
                this.multiplayerActive = true;
                
                // Simulate connection (would use actual WebRTC/WebSocket)
                setTimeout(() => {
                    if (this.roomStatusElement) {
                        this.roomStatusElement.textContent = `Connected! Room: ${this.roomId}`;
                        this.roomStatusElement.style.color = '#2ECC71';
                    }
                    
                    // Start multiplayer game
                    if (this.gameState === 'waiting') {
                        this.startGame();
                    }
                }, 1000);
            }

            sendMultiplayerData(data) {
                if (!this.multiplayerActive || !this.dataChannel) return;
                
                try {
                    this.dataChannel.send(JSON.stringify(data));
                } catch (e) {
                    console.error('Failed to send multiplayer data:', e);
                }
            }

            receiveMultiplayerData(data) {
                try {
                    const message = JSON.parse(data);
                    // Handle remote player data
                    if (message.type === 'playerUpdate') {
                        this.remotePlayer = message.data;
                    }
                } catch (e) {
                    console.error('Failed to parse multiplayer data:', e);
                }
            }

            updatePowerUps() {
                // Update coins (safe iteration with error handling)
                try {
                    this.coins.forEach((coin, index) => {
                        if (coin && !coin.collected) {
                            // Safe property access with fallbacks
                            if (typeof coin.x === 'number' && coin.velocity && typeof coin.velocity.x === 'number') {
                                coin.x += coin.velocity.x;
                            }
                            if (typeof coin.y === 'number' && coin.velocity && typeof coin.velocity.y === 'number') {
                                coin.y += coin.velocity.y;
                            }
                            if (typeof coin.rotation === 'number') {
                                coin.rotation += 0.1;
                            }
                            
                            // Handle glow phase for rarity coins
                            if (typeof coin.glowPhase === 'number') {
                                coin.glowPhase += 0.1;
                            }
                            
                            // Bounce off edges (safe bounds checking)
                            if (typeof coin.size === 'number') {
                                if (coin.x <= coin.size || coin.x >= this.gameWidth - coin.size) {
                                    if (coin.velocity && typeof coin.velocity.x === 'number') {
                                        coin.velocity.x *= -1;
                                    }
                                }
                                if (coin.y <= coin.size || coin.y >= this.gameHeight - 100) {
                                    if (coin.velocity && typeof coin.velocity.y === 'number') {
                                        coin.velocity.y *= -1;
                                    }
                                }
                                
                                // Keep within bounds
                                coin.x = Math.max(coin.size, Math.min(this.gameWidth - coin.size, coin.x));
                                coin.y = Math.max(coin.size, Math.min(this.gameHeight - 100, coin.y));
                            }
                        }
                    });
                    
                    // Remove coins that have expired (based on gates passed) - safe filtering
                    this.coins = this.coins.filter(coin => {
                        if (!coin) return false; // Remove null/undefined coins
                        // Keep old coins without gatesRemaining property
                        if (coin.gatesRemaining === undefined) {
                            return true;
                        }
                        return coin.gatesRemaining > 0;
                    });
                    
                } catch (error) {
                    console.error('Error updating coins:', error);
                    // Reset coins array if there's a critical error
                    this.coins = [];
                }
                
                // Update rockets
                this.rockets.forEach((rocket, index) => {
                    if (!rocket.collected) {
                        rocket.x += rocket.velocity.x;
                        rocket.y += rocket.velocity.y;
                        rocket.rotation += 0.05;
                        
                        // Bounce off edges
                        if (rocket.x <= rocket.size || rocket.x >= this.gameWidth - rocket.size) {
                            rocket.velocity.x *= -1;
                        }
                        if (rocket.y <= rocket.size || rocket.y >= this.gameHeight - 100) {
                            rocket.velocity.y *= -1;
                        }
                        
                        // Keep within bounds
                        rocket.x = Math.max(rocket.size, Math.min(this.gameWidth - rocket.size, rocket.x));
                        rocket.y = Math.max(rocket.size, Math.min(this.gameHeight - 100, rocket.y));
                    }
                });
                
                // Update invincibility timer
                if (this.invincible) {
                    this.invincibleTimeLeft -= 16; // Assuming 60fps
                    if (this.invincibleTimeLeft <= 0) {
                        this.invincible = false;
                        this.invincibleTimeElement.style.display = 'none';
                    } else {
                        this.invincibleTimeElement.textContent = `‚ú® ${Math.ceil(this.invincibleTimeLeft / 1000)}s`;
                    }
                }
                
                // Update rocket timer
                if (this.rocketActive) {
                    this.rocketTimeLeft -= 16; // Assuming 60fps
                    if (this.rocketTimeLeft <= 0) {
                        this.rocketActive = false;
                        this.rocketTimeElement.style.display = 'none';
                    } else {
                        this.rocketTimeElement.textContent = `üöÄ ${Math.ceil(this.rocketTimeLeft / 1000)}s`;
                    }
                }
                
                // Update rocket boost timer
                if (this.rocketBoostActive) {
                    this.rocketBoostTimeLeft -= 16; // Assuming 60fps
                    if (this.rocketBoostTimeLeft <= 0) {
                        this.rocketBoostActive = false;
                        this.rocketBoostActiveElement.style.display = 'none';
                    } else {
                        this.rocketBoostActiveElement.textContent = `‚ö°‚ö° BOOST! ${(this.rocketBoostTimeLeft / 1000).toFixed(1)}s`;
                    }
                }
                
                // Update rocket boosts
                this.rocketBoosts.forEach((boost, index) => {
                    if (!boost.collected) {
                        boost.x += boost.velocity.x;
                        boost.y += boost.velocity.y;
                        boost.rotation += 0.2;
                        boost.glow += 0.15;
                        
                        // Bounce off edges
                        if (boost.x <= boost.size || boost.x >= this.gameWidth - boost.size) {
                            boost.velocity.x *= -1;
                        }
                        if (boost.y <= boost.size || boost.y >= this.gameHeight - 100) {
                            boost.velocity.y *= -1;
                        }
                        
                        // Keep within bounds
                        boost.x = Math.max(boost.size, Math.min(this.gameWidth - boost.size, boost.x));
                        boost.y = Math.max(boost.size, Math.min(this.gameHeight - 100, boost.y));
                    }
                });

                // Update magnets
                this.magnets.forEach((magnet, index) => {
                    if (!magnet.collected) {
                        magnet.x += magnet.velocity.x;
                        magnet.y += magnet.velocity.y;
                        magnet.rotation += 0.15;
                        magnet.glow += 0.1;
                        
                        // Bounce off edges
                        if (magnet.x <= magnet.size || magnet.x >= this.gameWidth - magnet.size) {
                            magnet.velocity.x *= -1;
                        }
                        if (magnet.y <= magnet.size || magnet.y >= this.gameHeight - 100) {
                            magnet.velocity.y *= -1;
                        }
                        
                        // Keep within bounds
                        magnet.x = Math.max(magnet.size, Math.min(this.gameWidth - magnet.size, magnet.x));
                        magnet.y = Math.max(magnet.size, Math.min(this.gameHeight - 100, magnet.y));
                    }
                });

                // Update freezes
                this.freezes.forEach((freeze, index) => {
                    if (!freeze.collected) {
                        freeze.x += freeze.velocity.x;
                        freeze.y += freeze.velocity.y;
                        freeze.rotation += 0.12;
                        freeze.glow += 0.1;
                        
                        // Bounce off edges
                        if (freeze.x <= freeze.size || freeze.x >= this.gameWidth - freeze.size) {
                            freeze.velocity.x *= -1;
                        }
                        if (freeze.y <= freeze.size || freeze.y >= this.gameHeight - 100) {
                            freeze.velocity.y *= -1;
                        }
                        
                        // Keep within bounds
                        freeze.x = Math.max(freeze.size, Math.min(this.gameWidth - freeze.size, freeze.x));
                        freeze.y = Math.max(freeze.size, Math.min(this.gameHeight - 100, freeze.y));
                    }
                });

                // Update double points
                this.doublePoints.forEach((doublePoint, index) => {
                    if (!doublePoint.collected) {
                        doublePoint.x += doublePoint.velocity.x;
                        doublePoint.y += doublePoint.velocity.y;
                        doublePoint.rotation += 0.1;
                        doublePoint.glow += 0.1;
                        
                        // Bounce off edges
                        if (doublePoint.x <= doublePoint.size || doublePoint.x >= this.gameWidth - doublePoint.size) {
                            doublePoint.velocity.x *= -1;
                        }
                        if (doublePoint.y <= doublePoint.size || doublePoint.y >= this.gameHeight - 100) {
                            doublePoint.velocity.y *= -1;
                        }
                        
                        // Keep within bounds
                        doublePoint.x = Math.max(doublePoint.size, Math.min(this.gameWidth - doublePoint.size, doublePoint.x));
                        doublePoint.y = Math.max(doublePoint.size, Math.min(this.gameHeight - 100, doublePoint.y));
                    }
                });

                // Update magnet timer and attract coins
                if (this.magnetActive) {
                    this.magnetTimeLeft -= 16;
                    if (this.magnetTimeLeft <= 0) {
                        this.magnetActive = false;
                    } else {
                        // Attract coins to robot
                        this.coins.forEach(coin => {
                            if (!coin.collected) {
                                const dx = this.robot.x - coin.x;
                                const dy = this.robot.y - coin.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance > 0 && distance < 200) {
                                    const pullStrength = (200 - distance) / 200 * 0.3;
                                    coin.velocity.x += (dx / distance) * pullStrength;
                                    coin.velocity.y += (dy / distance) * pullStrength;
                                }
                            }
                        });
                    }
                }

                // Update freeze timer
                if (this.freezeActive) {
                    this.freezeTimeLeft -= 16;
                    if (this.freezeTimeLeft <= 0) {
                        this.freezeActive = false;
                    }
                }

                // Update double points timer
                if (this.doublePointsActive) {
                    this.doublePointsTimeLeft -= 16;
                    if (this.doublePointsTimeLeft <= 0) {
                        this.doublePointsActive = false;
                    }
                }
                
                // Update super coins
                this.superCoins.forEach((superCoin, index) => {
                    if (!superCoin.collected) {
                        superCoin.x += superCoin.velocity.x;
                        superCoin.y += superCoin.velocity.y;
                        superCoin.rotation += 0.15;
                        superCoin.glow += 0.2;
                        
                        // Bounce off edges
                        if (superCoin.x <= superCoin.size || superCoin.x >= this.gameWidth - superCoin.size) {
                            superCoin.velocity.x *= -1;
                        }
                        if (superCoin.y <= superCoin.size || superCoin.y >= this.gameHeight - 100) {
                            superCoin.velocity.y *= -1;
                        }
                        
                        // Keep within bounds
                        superCoin.x = Math.max(superCoin.size, Math.min(this.gameWidth - superCoin.size, superCoin.x));
                        superCoin.y = Math.max(superCoin.size, Math.min(this.gameHeight - 100, superCoin.y));
                    }
                });
                
                // Update oil cans
                this.oilCans.forEach((oilCan, index) => {
                    oilCan.x += oilCan.velocity.x;
                    oilCan.y += oilCan.velocity.y;
                    oilCan.rotation += 0.02;
                    oilCan.bobPhase += 0.1;
                    
                    // Bounce off edges
                    if (oilCan.x <= oilCan.size || oilCan.x >= this.gameWidth - oilCan.size) {
                        oilCan.velocity.x *= -1;
                    }
                    if (oilCan.y <= oilCan.size || oilCan.y >= this.gameHeight - 100) {
                        oilCan.velocity.y *= -1;
                    }
                    
                    // Keep within bounds
                    oilCan.x = Math.max(oilCan.size, Math.min(this.gameWidth - oilCan.size, oilCan.x));
                    oilCan.y = Math.max(oilCan.size, Math.min(this.gameHeight - 100, oilCan.y));
                });
                
                // Update missiles - DISABLED (missiles cause red dots and freeze)
                // AGGRESSIVELY clear all missiles EVERY FRAME to prevent red dots
                this.missiles = [];
                if (this.missiles && this.missiles.length > 0) {
                    this.missiles = [];
                }
                // DISABLED: this.missiles.forEach((missile, index) => {
                //     missile.life += 16; // Track missile lifetime
                //     
                //     // Spiral movement calculation
                //     missile.spiralPhase += missile.spiralSpeed;
                //     const spiralOffsetX = Math.cos(missile.spiralPhase) * missile.spiralRadius * 0.1;
                //     const spiralOffsetY = Math.sin(missile.spiralPhase) * missile.spiralRadius * 0.1;
                //     
                //     // Apply spiral offset to base movement
                //     missile.x += missile.velocity.x + spiralOffsetX;
                //     missile.y += missile.velocity.y + spiralOffsetY;
                //     
                //     // Update rotation based on movement direction
                //     const currentAngle = Math.atan2(missile.velocity.y + spiralOffsetY, missile.velocity.x + spiralOffsetX);
                //     missile.rotation = currentAngle;
                //     
                //     // Remove missiles that are off screen or have lived too long
                //     if (missile.x < -50 || missile.x > this.gameWidth + 50 || 
                //         missile.y < -50 || missile.y > this.gameHeight + 50 ||
                //         missile.life > 5000) { // 5 second max lifetime
                //         this.missiles.splice(index, 1);
                //     }
                // });
                
                // Update super coin timer
                if (this.superCoinActive) {
                    this.superCoinTimeLeft -= 16;
                    if (this.superCoinTimeLeft <= 0) {
                        this.superCoinActive = false;
                        this.superCoinTimeElement.style.display = 'none';
                    } else {
                        this.superCoinTimeElement.textContent = `‚≠ê ${Math.ceil(this.superCoinTimeLeft / 1000)}s`;
                    }
                }
                
                // Update power bar
                this.powerBarFill.style.width = `${this.robotPower}%`;
                
                // Update player 2 status
                if (!this.player1FirstCoinCollected) {
                    this.player2StatusElement.textContent = `Player 2: üîí Locked (collect first coin)`;
                    this.player2StatusElement.style.color = '#999';
                } else {
                    this.player2StatusElement.textContent = `Player 2: üöÄ ${this.player2Missiles}`;
                    this.player2StatusElement.style.color = '';
                }
                
                // Update UI
                this.shieldCountElement.textContent = `üõ°Ô∏è ${this.shieldCount}`;
                
                // Update rocket boost stored display
                if (this.rocketBoostStored > 0 && !this.rocketBoostActive) {
                    this.rocketBoostStoredElement.style.display = 'inline-block';
                    this.rocketBoostStoredElement.textContent = `‚ö° Boost: ${(this.rocketBoostStored / 1000).toFixed(1)}s`;
                } else if (!this.rocketBoostActive) {
                    this.rocketBoostStoredElement.style.display = 'none';
                }
            }

            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.gameWidth, this.gameHeight);

                // Draw background gradient based on current theme
                this.drawBackground();

                // Draw clouds
                this.drawClouds();

                // Draw ground
                this.ctx.fillStyle = '#8FBC8F';
                this.ctx.fillRect(0, this.gameHeight - 50, this.gameWidth, 50);

                // Draw obstacles
                this.drawObstacles();


                // Draw power-ups
                this.drawPowerUps();

                // Draw super coins
                this.drawSuperCoins();

                // Draw rocket boosts
                this.drawRocketBoosts();


                // Draw freezes
                this.drawFreezes();

                // Draw double points
                this.drawDoublePoints();

                // Draw oil cans
                this.drawOilCans();


                // Draw robot
                this.drawRobot();
            }

            drawBackground() {
                const bg = this.backgrounds[this.currentBackground];
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.gameHeight);
                
                bg.gradient.forEach((color, index) => {
                    const stop = index / (bg.gradient.length - 1);
                    gradient.addColorStop(stop, color);
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.gameWidth, this.gameHeight);
            }

            drawClouds() {
                const cloudColor = this.backgrounds[this.currentBackground].cloudColor;
                this.clouds.forEach(cloud => {
                    this.ctx.fillStyle = cloudColor;
                    this.ctx.beginPath();
                    this.ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
                    this.ctx.arc(cloud.x + cloud.size * 0.5, cloud.y, cloud.size * 0.8, 0, Math.PI * 2);
                    this.ctx.arc(cloud.x - cloud.size * 0.5, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            drawObstacles() {
                this.ctx.fillStyle = '#2F4F4F';
                this.obstacles.forEach(obstacle => {
                    // Top obstacle
                    this.ctx.fillRect(obstacle.x, 0, obstacle.width, obstacle.topHeight);
                    // Bottom obstacle
                    this.ctx.fillRect(obstacle.x, obstacle.bottomY, obstacle.width, this.gameHeight - obstacle.bottomY);
                });
            }

            drawRobot() {
                this.ctx.save();
                this.ctx.translate(this.robot.x + this.robot.width / 2, this.robot.y + this.robot.height / 2);
                this.ctx.rotate(this.robot.rotation * Math.PI / 180);
                
                // Draw invincibility effect
                if (this.invincible) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = '#9B59B6';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, this.robot.width + 10, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }
                
                // Robot body (main chassis)
                this.ctx.fillStyle = '#2C3E50';
                this.ctx.fillRect(-this.robot.width / 2, -this.robot.height / 2, this.robot.width, this.robot.height);
                
                // Robot head
                this.ctx.fillStyle = '#34495E';
                this.ctx.fillRect(-this.robot.width / 2 + 5, -this.robot.height / 2 - 8, this.robot.width - 10, 12);
                
                // Robot eyes (with glow effect)
                const eyeGlow = this.robot.eyeGlow;
                this.ctx.fillStyle = `rgba(52, 152, 219, ${0.3 + eyeGlow * 0.7})`;
                this.ctx.fillRect(-this.robot.width / 2 + 8, -this.robot.height / 2 - 4, 6, 4);
                this.ctx.fillRect(-this.robot.width / 2 + 18, -this.robot.height / 2 - 4, 6, 4);
                
                // Robot eye pupils
                this.ctx.fillStyle = '#3498DB';
                this.ctx.fillRect(-this.robot.width / 2 + 9, -this.robot.height / 2 - 3, 4, 2);
                this.ctx.fillRect(-this.robot.width / 2 + 19, -this.robot.height / 2 - 3, 4, 2);
                
                // Robot arms (wings)
                this.ctx.fillStyle = '#7F8C8D';
                this.ctx.fillRect(-this.robot.width / 2 - 8, -this.robot.height / 2 + 3, 12, 6);
                this.ctx.fillRect(-this.robot.width / 2 - 8, this.robot.height / 2 - 9, 12, 6);
                
                // Robot legs
                this.ctx.fillStyle = '#95A5A6';
                this.ctx.fillRect(-this.robot.width / 2 + 5, this.robot.height / 2 - 2, 6, 8);
                this.ctx.fillRect(-this.robot.width / 2 + 15, this.robot.height / 2 - 2, 6, 8);
                
                // Robot chest panel
                this.ctx.fillStyle = '#E74C3C';
                this.ctx.fillRect(-this.robot.width / 2 + 8, -this.robot.height / 2 + 8, this.robot.width - 16, 8);
                
                // Robot antenna
                this.ctx.strokeStyle = '#F39C12';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -this.robot.height / 2 - 8);
                this.ctx.lineTo(0, -this.robot.height / 2 - 15);
                this.ctx.stroke();
                
                // Antenna tip
                this.ctx.fillStyle = '#F39C12';
                this.ctx.beginPath();
                this.ctx.arc(0, -this.robot.height / 2 - 15, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
            }

            drawPowerUps() {
                // Draw coins with rarity-based styling
                this.coins.forEach(coin => {
                    if (!coin.collected) {
                        this.ctx.save();
                        this.ctx.translate(coin.x, coin.y);
                        this.ctx.rotate(coin.rotation);
                        
                        // Handle coin rarity (backward compatibility)
                        if (coin.rarity) {
                            // Dynamic glow based on rarity
                            this.ctx.shadowColor = coin.rarity.color;
                            this.ctx.shadowBlur = 8 + (coin.rarity.value * 2);
                            
                            // Coin body with rarity color
                            this.ctx.fillStyle = coin.rarity.color;
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Coin inner circle (lighter shade)
                            const lighterColor = this.lightenColor(coin.rarity.color, 0.3);
                            this.ctx.fillStyle = lighterColor;
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, coin.size * 0.7, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Rarity-specific symbol
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = `bold ${coin.size * 0.8}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            
                            const symbol = this.getCoinSymbol(coin.rarity.name);
                            this.ctx.fillText(symbol, 0, 0);
                            
                            // Rarity border for higher value coins
                            if (coin.rarity.value >= 5) {
                                this.ctx.strokeStyle = '#FFFFFF';
                                this.ctx.lineWidth = 2;
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
                                this.ctx.stroke();
                            }
                            
                            // Pulsing effect for rare coins
                            if (coin.rarity.value >= 8) {
                                const pulse = Math.sin(coin.glowPhase || 0) * 0.2 + 0.8;
                                this.ctx.globalAlpha = pulse;
                                this.ctx.fillStyle = coin.rarity.color;
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, coin.size * 1.2, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.globalAlpha = 1;
                            }
                        } else {
                            // Fallback for old coins without rarity
                            this.ctx.shadowColor = '#F1C40F';
                            this.ctx.shadowBlur = 10;
                            
                            // Coin body
                            this.ctx.fillStyle = '#F1C40F';
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Coin shine
                            this.ctx.fillStyle = '#F7DC6F';
                            this.ctx.beginPath();
                            this.ctx.arc(-coin.size * 0.3, -coin.size * 0.3, coin.size * 0.4, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Coin symbol
                            this.ctx.fillStyle = '#D4AC0D';
                            this.ctx.font = `${coin.size * 0.8}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText('$', 0, 0);
                        }
                        
                        this.ctx.restore();
                    }
                });
                
                // Draw rockets
                this.rockets.forEach(rocket => {
                    if (!rocket.collected) {
                        this.ctx.save();
                        this.ctx.translate(rocket.x, rocket.y);
                        this.ctx.rotate(rocket.rotation);
                        
                        // Rocket body
                        this.ctx.fillStyle = '#E74C3C';
                        this.ctx.fillRect(-rocket.size * 0.3, -rocket.size * 0.5, rocket.size * 0.6, rocket.size);
                        
                        // Rocket nose
                        this.ctx.fillStyle = '#C0392B';
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -rocket.size * 0.5);
                        this.ctx.lineTo(-rocket.size * 0.2, -rocket.size * 0.3);
                        this.ctx.lineTo(rocket.size * 0.2, -rocket.size * 0.3);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Rocket fins
                        this.ctx.fillStyle = '#A93226';
                        this.ctx.fillRect(-rocket.size * 0.4, rocket.size * 0.2, rocket.size * 0.2, rocket.size * 0.3);
                        this.ctx.fillRect(rocket.size * 0.2, rocket.size * 0.2, rocket.size * 0.2, rocket.size * 0.3);
                        
                        // Rocket flame
                        this.ctx.fillStyle = '#F39C12';
                        this.ctx.beginPath();
                        this.ctx.arc(0, rocket.size * 0.6, rocket.size * 0.2, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.restore();
                    }
                });
            }

            drawRocketBoosts() {
                this.rocketBoosts.forEach(boost => {
                    if (!boost.collected) {
                        this.ctx.save();
                        this.ctx.translate(boost.x, boost.y);
                        this.ctx.rotate(boost.rotation);
                        
                        // Glow effect
                        const glowIntensity = Math.sin(boost.glow) * 0.3 + 0.7;
                        this.ctx.shadowColor = '#FF6B6B';
                        this.ctx.shadowBlur = 15 + Math.sin(boost.glow) * 5;
                        
                        // Boost body (orange/red gradient)
                        const gradient = this.ctx.createLinearGradient(-boost.size * 0.5, 0, boost.size * 0.5, 0);
                        gradient.addColorStop(0, '#FF6B6B');
                        gradient.addColorStop(1, '#FF8C42');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, boost.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Boost symbol (lightning bolt)
                        this.ctx.fillStyle = '#FFD700';
                        this.ctx.font = `bold ${boost.size * 0.8}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('‚ö°', 0, 0);
                        
                        // Pulsing outer ring
                        this.ctx.strokeStyle = '#FF6B6B';
                        this.ctx.lineWidth = 2;
                        this.ctx.globalAlpha = glowIntensity * 0.5;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, boost.size * 1.3, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1;
                        
                        this.ctx.restore();
                    }
                });
            }


            drawFreezes() {
                this.freezes.forEach(freeze => {
                    if (!freeze.collected) {
                        this.ctx.save();
                        this.ctx.translate(freeze.x, freeze.y);
                        this.ctx.rotate(freeze.rotation);
                        
                        const glowIntensity = Math.sin(freeze.glow) * 0.3 + 0.7;
                        this.ctx.shadowColor = '#3498DB';
                        this.ctx.shadowBlur = 14 + Math.sin(freeze.glow) * 4;
                        
                        // Freeze body (blue gradient)
                        const gradient = this.ctx.createLinearGradient(-freeze.size * 0.5, 0, freeze.size * 0.5, 0);
                        gradient.addColorStop(0, '#3498DB');
                        gradient.addColorStop(1, '#2980B9');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, freeze.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Freeze symbol
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.font = `bold ${freeze.size * 0.7}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('‚ùÑÔ∏è', 0, 0);
                        
                        this.ctx.restore();
                    }
                });
            }

            drawDoublePoints() {
                this.doublePoints.forEach(doublePoint => {
                    if (!doublePoint.collected) {
                        this.ctx.save();
                        this.ctx.translate(doublePoint.x, doublePoint.y);
                        this.ctx.rotate(doublePoint.rotation);
                        
                        const glowIntensity = Math.sin(doublePoint.glow) * 0.3 + 0.7;
                        this.ctx.shadowColor = '#F39C12';
                        this.ctx.shadowBlur = 16 + Math.sin(doublePoint.glow) * 5;
                        
                        // Double points body (orange gradient)
                        const gradient = this.ctx.createLinearGradient(-doublePoint.size * 0.5, 0, doublePoint.size * 0.5, 0);
                        gradient.addColorStop(0, '#F39C12');
                        gradient.addColorStop(1, '#E67E22');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, doublePoint.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Double points symbol
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.font = `bold ${doublePoint.size * 0.6}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('‚úñÔ∏è', 0, 0);
                        
                        this.ctx.restore();
                    }
                });
            }

            drawSuperCoins() {
                this.superCoins.forEach(superCoin => {
                    if (!superCoin.collected) {
                        this.ctx.save();
                        this.ctx.translate(superCoin.x, superCoin.y);
                        this.ctx.rotate(superCoin.rotation);
                        
                        // Glow effect
                        this.ctx.shadowColor = '#F39C12';
                        this.ctx.shadowBlur = 20 + Math.sin(superCoin.glow) * 10;
                        
                        // Super coin body
                        this.ctx.fillStyle = '#F39C12';
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, superCoin.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Super coin shine
                        this.ctx.fillStyle = '#F7DC6F';
                        this.ctx.beginPath();
                        this.ctx.arc(-superCoin.size * 0.3, -superCoin.size * 0.3, superCoin.size * 0.4, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Super coin symbol
                        this.ctx.fillStyle = '#D4AC0D';
                        this.ctx.font = `${superCoin.size * 0.8}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('‚≠ê', 0, 0);
                        
                        this.ctx.restore();
                    }
                });
            }

            drawOilCans() {
                this.oilCans.forEach(oilCan => {
                    this.ctx.save();
                    this.ctx.translate(oilCan.x, oilCan.y);
                    this.ctx.rotate(oilCan.rotation);
                    
                    // Oil can glow
                    this.ctx.shadowColor = '#8B4513';
                    this.ctx.shadowBlur = 8;
                    
                    // Bobbing effect
                    const bobOffset = Math.sin(oilCan.bobPhase) * 3;
                    this.ctx.translate(0, bobOffset);
                    
                    // Oil can body (brown metal)
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(-oilCan.size, -oilCan.size * 0.8, oilCan.size * 2, oilCan.size * 1.6);
                    
                    // Oil can top rim (darker brown)
                    this.ctx.fillStyle = '#654321';
                    this.ctx.fillRect(-oilCan.size * 0.9, -oilCan.size * 0.9, oilCan.size * 1.8, oilCan.size * 0.2);
                    
                    // Oil can bottom rim
                    this.ctx.fillStyle = '#654321';
                    this.ctx.fillRect(-oilCan.size * 0.9, oilCan.size * 0.7, oilCan.size * 1.8, oilCan.size * 0.2);
                    
                    // Oil can spout (metal)
                    this.ctx.fillStyle = '#A0522D';
                    this.ctx.fillRect(-oilCan.size * 0.2, -oilCan.size * 1.0, oilCan.size * 0.4, oilCan.size * 0.3);
                    
                    // Oil can handle
                    this.ctx.strokeStyle = '#654321';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(oilCan.size * 0.7, -oilCan.size * 0.3, oilCan.size * 0.3, 0, Math.PI);
                    this.ctx.stroke();
                    
                    // Oil can label background
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.fillRect(-oilCan.size * 0.7, -oilCan.size * 0.3, oilCan.size * 1.4, oilCan.size * 0.4);
                    
                    // Oil can label text
                    this.ctx.fillStyle = '#000000';
                    this.ctx.font = `bold ${oilCan.size * 0.25}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('OIL', 0, oilCan.size * 0.1);
                    
                    // Oil can warning symbol
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.font = `${oilCan.size * 0.2}px Arial`;
                    this.ctx.fillText('‚ö†', 0, oilCan.size * 0.4);
                    
                    // Oil droplets around can
                    this.ctx.fillStyle = '#2E8B57';
                    for (let i = 0; i < 4; i++) {
                        const angle = (oilCan.bobPhase + i * 1.5) * 0.3;
                        const dropletX = Math.cos(angle) * oilCan.size * 1.8;
                        const dropletY = Math.sin(angle) * oilCan.size * 1.8;
                        this.ctx.beginPath();
                        this.ctx.arc(dropletX, dropletY, 1.5, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }


            gameLoop() {
                this.update();
                this.draw();
                this.updateMusic();
                
                // Auto-save every 30 seconds
                const now = Date.now();
                if (now - this.lastAutoSaveTime > this.autoSaveInterval) {
                    this.autoSave();
                    this.lastAutoSaveTime = now;
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }

            // Audio System
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Audio context starts suspended - will resume on user interaction
                    if (this.audioContext.state === 'suspended') {
                        this.audioContextReady = false;
                    } else {
                        this.audioContextReady = true;
                        this.startMusic();
                    }
                } catch (e) {
                    console.log("Audio not supported");
                    this.soundEnabled = false;
                    this.audioContextReady = false;
                }
            }

            resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume().then(() => {
                        this.audioContextReady = true;
                        if (this.soundEnabled && !this.musicPlaying) {
                            this.startMusic();
                        }
                        console.log("Audio context resumed");
                    }).catch(err => {
                        console.error("Failed to resume audio context:", err);
                    });
                }
            }

            startMusic() {
                if (!this.soundEnabled) return;
                
                // Try to resume audio context if suspended
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.resumeAudioContext();
                    // Wait a bit for context to resume
                    setTimeout(() => {
                        if (this.audioContextReady && !this.musicPlaying) {
                            this.musicPlaying = true;
                            this.musicTime = 0;
                        }
                    }, 100);
                    return;
                }
                
                if (this.musicPlaying || !this.audioContextReady) return;
                
                this.musicPlaying = true;
                this.musicTime = 0;
            }

            updateMusic() {
                if (!this.soundEnabled || !this.musicPlaying) return;
                
                this.musicTime += 16; // Assuming 60fps
                const beatTime = 60000 / this.musicTempo; // Convert BPM to ms per beat
                
                if (this.musicTime >= beatTime) {
                    this.playMusicBeat();
                    this.musicTime = 0;
                    this.musicPattern++;
                }
            }

            playMusicBeat() {
                if (!this.audioContext || !this.audioContextReady) return;
                
                // Create catchy viral melody with multiple layers
                this.playMelodyLayer();
                this.playBassLayer();
                this.playPercussionLayer();
            }

            playMelodyLayer() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Catchy viral melody - more memorable progression
                const melody = [
                    [0, 4, 7, 12],    // C major chord progression
                    [2, 5, 9, 14],    // D minor
                    [4, 7, 11, 16],   // E minor
                    [5, 9, 12, 17],   // F major
                    [7, 11, 14, 19],  // G major
                    [9, 12, 16, 21],  // A minor
                    [11, 14, 17, 22], // B diminished
                    [12, 16, 19, 24]  // C major octave
                ];
                
                const pattern = melody[Math.floor(this.musicPattern / 4) % melody.length];
                const note = pattern[this.musicPattern % pattern.length];
                
                // Dynamic base frequency based on game state
                let baseFreq = 220 + (this.musicIntensity * 50);
                if (this.rocketActive) {
                    baseFreq *= 0.8; // Lower when in slow motion
                } else if (this.invincible) {
                    baseFreq *= 1.2; // Higher when invincible
                } else if (this.superCoinActive) {
                    baseFreq *= 1.3; // Higher during super coin frenzy
                }
                
                const frequency = baseFreq * Math.pow(2, note / 12);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sawtooth';
                
                // Add filter sweep for more character
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800 + Math.sin(this.musicPattern * 0.5) * 200, this.audioContext.currentTime);
                
                // Dynamic volume based on game state
                let volume = 0.03 * this.musicIntensity;
                if (this.rocketActive) {
                    volume *= 0.6; // Quieter during slow motion
                } else if (this.invincible) {
                    volume *= 1.3; // Louder when invincible
                } else if (this.superCoinActive) {
                    volume *= 1.5; // Much louder during super coin frenzy
                }
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume * this.musicVolume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }

            playBassLayer() {
                if (this.musicPattern % 2 !== 0) return; // Play every other beat
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Bass line that follows the melody
                const bassNotes = [0, 0, 4, 4, 7, 7, 12, 12];
                const note = bassNotes[Math.floor(this.musicPattern / 2) % bassNotes.length];
                const baseFreq = 110 + (this.musicIntensity * 25);
                const frequency = baseFreq * Math.pow(2, note / 12);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'triangle';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.02 * this.musicIntensity * this.musicVolume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.4);
            }

            playPercussionLayer() {
                if (this.musicPattern % 4 !== 0) return; // Play every 4th beat
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Percussion-like sound
                oscillator.frequency.setValueAtTime(60 + Math.random() * 40, this.audioContext.currentTime);
                oscillator.type = 'square';
                
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01 * this.musicIntensity * this.musicVolume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            playSound(type) {
                if (!this.soundEnabled) return;
                
                // Ensure audio context exists
                if (!this.audioContext) {
                    this.initAudio();
                    return;
                }
                
                // Try to resume audio context if suspended
                if (this.audioContext.state === 'suspended') {
                    this.resumeAudioContext();
                    // Play sound after a short delay to allow context to resume
                    setTimeout(() => this.playSound(type), 50);
                    return;
                }
                
                // Set ready if context is running
                if (this.audioContext.state === 'running' && !this.audioContextReady) {
                    this.audioContextReady = true;
                }
                
                if (!this.audioContextReady) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                let frequency, duration, waveType;
                
                switch(type) {
                    case 'coin':
                        frequency = 1200;
                        duration = 0.08;
                        waveType = 'sine';
                        break;
                    case 'superCoin':
                        frequency = 1600;
                        duration = 0.2;
                        waveType = 'sawtooth';
                        break;
                    case 'rocket':
                        frequency = 800;
                        duration = 0.15;
                        waveType = 'square';
                        break;
                    case 'missile':
                        frequency = 300;
                        duration = 0.12;
                        waveType = 'triangle';
                        break;
                    case 'damage':
                        frequency = 150;
                        duration = 0.25;
                        waveType = 'sawtooth';
                        break;
                    case 'shield':
                        frequency = 1400;
                        duration = 0.15;
                        waveType = 'sine';
                        break;
                    case 'jump':
                        frequency = 600;
                        duration = 0.08;
                        waveType = 'square';
                        break;
                    case 'oilCan':
                        // "Fill up gulp" sound effect
                        frequency = 400;
                        duration = 0.3;
                        waveType = 'sawtooth';
                        break;
                    case 'gameOver':
                        // Classic "whaa whaa wha whaaaaaaa" descending sound
                        this.playGameOverSound();
                        return;
                    default:
                        return;
                }
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = waveType;
                
                // Volume envelope - use sound effect volume setting
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.4 * this.soundEffectVolume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            updateMusicIntensity() {
                // Increase music intensity based on level - more dramatic progression
                this.musicIntensity = 1 + (this.level - 1) * 0.4;
                this.musicTempo = 140 + (this.level - 1) * 25; // Faster tempo progression
            }

            playGameOverSound() {
                if (!this.soundEnabled || !this.audioContext || !this.audioContextReady) return;
                
                // Stop the background music
                this.musicPlaying = false;
                
                // Create the classic "whaa whaa wha whaaaaaaa" descending sound
                const notes = [
                    { freq: 523.25, duration: 0.3 }, // C5
                    { freq: 392.00, duration: 0.3 }, // G4
                    { freq: 349.23, duration: 0.3 }, // F4
                    { freq: 261.63, duration: 0.8 }  // C4 (longer)
                ];
                
                let startTime = this.audioContext.currentTime;
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(note.freq, startTime);
                    oscillator.type = 'sawtooth';
                    
                    // Add filter sweep for that classic arcade sound
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, startTime);
                    filter.frequency.exponentialRampToValueAtTime(200, startTime + note.duration);
                    
                    // Volume envelope
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + note.duration);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + note.duration);
                    
                    startTime += note.duration;
                });
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new InTheAirGame();
        });
    </script>
</body>
</html>

